#!/bin/bash

# Library of functions for installation scripts
# Author: crims0n. <http://minios.dev>
#

# =================================================================
# =================================================================
# ========================= VARIABLES =============================
# =================================================================
# =================================================================

function common_variables() {
    local locale layout layoutcode

    # List of variables passed to chroot.
    VARIABLES="BATCH LOGPATH BUILD_TEST_ISO DEBIAN_FRONTEND_TYPE DESKTOP_ENVIRONMENT DISTRIBUTION DISTRIBUTION_TYPE PACKAGE_VARIANT COMP_TYPE KERNEL KERNEL_VERSION KERNEL_ARCH KERNEL_TYPE KERNEL_BPO KERNEL_AUFS KERNEL_BUILD_DKMS LIVEKITNAME SYSTEMNAME DISTRIBUTION_ARCH LOCALE LOCALES MULTILINGUAL LAYOUT LAYOUTCODE TIMEZONE MODULE USER_NAME USER_PASSWORD ROOT_PASSWORD INITRD_TYPE BEXT EXPORT_LOGS"

    #
    CONTAINER_TYPE="0"
    set +u
    if [ -z $container ]; then
        container=""
    fi
    if [ -z $MODULE ]; then
        MODULE=""
    fi
    set -u
    if [[ (-f /.dockerenv || "$container" = "podman") && ! -f /.minios-live-container ]]; then
        CONTAINER_TYPE="1"
    fi
    if [[ (-f /.dockerenv || "$container" = "podman") && -f /.minios-live-container ]]; then
        CONTAINER_TYPE="2"
    fi

    if [ $DISTRIBUTION_ARCH = "amd64" ]; then
        ISO_ARCH="amd64"
        KERNEL_ARCH="amd64"
    elif [ $DISTRIBUTION_ARCH = "i386-pae" ]; then
        ISO_ARCH="i386-pae"
        KERNEL_ARCH="686-pae"
        DISTRIBUTION_ARCH="i386"
    elif [ $DISTRIBUTION_ARCH = "i386" ]; then
        ISO_ARCH="i386"
        KERNEL_ARCH="686"
    elif [ $DISTRIBUTION_ARCH = "arm64" ]; then
        ISO_ARCH="arm64"
        KERNEL_ARCH="arm64"
    fi

    if [ $DESKTOP_ENVIRONMENT = "flux" ]; then
        PACKAGE_VARIANT="minimum"
        USER_NAME="root"
    fi

    if [ $DESKTOP_ENVIRONMENT = "cloud" ]; then
        PACKAGE_VARIANT="cloud"
        KERNEL_TYPE="cloud"
    fi
    if [ $DESKTOP_ENVIRONMENT = "pve" ]; then
        PACKAGE_VARIANT="pve"
        KERNEL_TYPE="pve"
    fi

    if [ $PACKAGE_VARIANT = "puzzle" ]; then
        SYSTEM_TYPE="puzzle"
    else
        SYSTEM_TYPE="classic"
        #SYSTEM_TYPE="puzzle"
    fi

    case $DISTRIBUTION in
    stretch | buster | bullseye | bookworm | kali-rolling | sid | orel)
        DISTRIBUTION_TYPE="debian"
        ;;
    bionic | cosmic | disco | eoan | focal | groovy | hirsute | impish | jammy | kinetic | lunar | mantic)
        DISTRIBUTION_TYPE="ubuntu"
        ;;
    *)
        echo "Unknown distribution: $DISTRIBUTION"
        exit 1
        ;;
    esac
    if [ $DISTRIBUTION_TYPE = "debian" ]; then
        if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
            DISTRIBUTION_URL="https://snapshot.debian.org/archive/debian/$SNAPSHOT_DATE"
        else
            DISTRIBUTION_URL="http://ftp.debian.org/debian"
        fi
    elif [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        DISTRIBUTION_URL="http://archive.ubuntu.com/ubuntu"
    fi

    if [ $DISTRIBUTION = "kali-rolling" ]; then
        DISTRIBUTION_URL="http://archive.kali.org/kali"
    fi

    if [ $DISTRIBUTION = "orel" ]; then
        DISTRIBUTION_URL="http://mirror.yandex.ru/astra/stable/2.12_x86-64/repository"
    fi

    if [ $DISTRIBUTION = "orel" ] && [ $COMP_TYPE = "zstd" ]; then
        COMP_TYPE="lz4"
    elif [ $DISTRIBUTION = "stretch" ] && ([ $COMP_TYPE = "zstd" ] || [ $COMP_TYPE = "lz4" ]); then
        COMP_TYPE="gzip"
    fi

    if [ -d /run/initramfs/memory/bundles ]; then
        BUNDLES=/run/initramfs/memory/bundles
    elif [ -d /memory/bundles ]; then
        BUNDLES=/memory/bundles
    fi

    if [ $INITRD_TYPE = "livekit-mos" ]; then
        INITRD_TYPE_SUFFIX="lkm"
    elif [ $INITRD_TYPE = "livekit-slax" ]; then
        INITRD_TYPE_SUFFIX="lks"
    elif [ $INITRD_TYPE = "uird" ]; then
        INITRD_TYPE_SUFFIX="uird"
    fi

    while IFS=, read -r locale layoutcode layout; do
        if [ "$locale" == "$LOCALE" ]; then
            LAYOUTCODE="$layoutcode"
            LAYOUT="$layout"
            break
        fi
    done <"$1"

    if [ -z "$LAYOUT" ]; then
        echo "Locale not recognized, defaulting to English (US) layout"
        LAYOUT="English (US)"
        LAYOUTCODE="us"
    fi

    # An array of locales. Used if MULTILINGUAL=true.
    LOCALES=("de_DE" "en_US" "es_ES" "fr_FR" "it_IT" "pt_BR" "ru_RU")

    if [ $MULTILINGUAL = "true" ]; then
        LANGUAGE_CODE=""
    else
        LANGUAGE_CODE="$(echo $LOCALE | cut -d_ -f1)-"
    fi

    # List of directories for root filesystem
    # No subdirectories are allowed, no slashes,
    # so You can't use /var/tmp here for example
    # Exclude directories like proc sys tmp
    MKMOD="bin etc home lib lib64 opt root sbin srv usr var"
}

# =================================================================
# =================================================================
# ===================== COMMON FUNCTIONS ==========================
# =================================================================
# =================================================================

function current_process() {
    echo -e "${LIGHTYELLOW}=====> running ${CYAN}${CMD[ii]}${ENDCOLOR}${LIGHTYELLOW} ...${ENDCOLOR}"
}

function current_function() {
    echo -e "=====> the ${CYAN}${FUNCNAME[1]}${ENDCOLOR} function is executing ..."
}

# =================================================================
# beautiful console
# =================================================================

function console_colors() {
    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    BLUE="\e[34m"
    MAGENTA="\e[35m"
    CYAN="\e[36m"
    LIGHTGRAY="\e[37m"
    DARKGRAY="\e[90m"
    LIGHTRED="\e[91m"
    LIGHTGREEN="\e[92m"
    LIGHTYELLOW="\e[93m"
    LIGHTBLUE="\e[94m"
    LIGHTMAGENTA="\e[95m"
    LIGHTCYAN="\e[96m"
    BOLD="\e[1m"
    DIM="\e[2m"
    UNDERLINED="\e[4m"
    BLINK="\e[5m"
    REVERSE="\e[7m"
    HIDDEN="\e[8m"
    ENDCOLOR="\e[0m"
}

# =================================================================
# help functions
# =================================================================

function help() {
    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        # if $1 is set, use $1 as headline message in help()
        if [ -z ${1+x} ]; then
            echo -e "${LIGHTYELLOW}This script builds bootable $SYSTEMNAME ISO image.${ENDCOLOR}"
            echo -e
        else
            echo -e $1
            echo
        fi
        echo -e "Supported commands: ${CYAN}${CMD[*]}${ENDCOLOR}" | fold -w 80 -s
        echo -e
        echo -e "Syntax: ${MAGENTA}$0${ENDCOLOR} [start_cmd] [-] [end_cmd]"
        echo -e "\trun from start_cmd to end_cmd"
        echo -e "\tif start_cmd is omitted, start from first command"
        echo -e "\tif end_cmd is omitted, end with last command"
        echo -e "\tenter single cmd to run the specific command"
        echo -e "\tenter '-' as only argument to run all commands"
        echo -e "\t"
        echo -e "Examples:"
        echo -e "\t${LIGHTYELLOW}$0 -${ENDCOLOR}"
        echo -e "\t${LIGHTYELLOW}$0 build_bootstrap - build_chroot${ENDCOLOR}"
        echo -e "\t${LIGHTYELLOW}$0 - build_chroot${ENDCOLOR}"
        echo -e "\t${LIGHTYELLOW}$0 build_bootstrap -${ENDCOLOR}"
        echo -e "\t${LIGHTYELLOW}$0 build_iso${ENDCOLOR}"
        exit 0
    else
        # if $1 is set, use $1 as headline message in help()
        if [ -z ${1+x} ]; then
            echo -e "${LIGHTYELLOW}This script builds modules for $SYSTEMNAME.${ENDCOLOR}"
            echo -e
        else
            echo -e $1
            echo
        fi
        echo -e "Supported commands : ${CYAN}${CMD[*]}${ENDCOLOR}" | fold -w 80 -s
        echo -e
        echo -e "Syntax: ${MAGENTA}$0${ENDCOLOR} [start_cmd] [-] [end_cmd]"
        echo -e "\trun from start_cmd to end_cmd"
        echo -e "\tif start_cmd is omitted, start from first command"
        echo -e "\tif end_cmd is omitted, end with last command"
        echo -e "\tenter single cmd to run the specific command"
        echo -e "\tenter '-' as only argument to run all commands"
        echo -e "\t"
        echo -e "\tThe installation scripts must be in the folder with the"
        echo -e "\tname of the future module. For example, to build a module"
        echo -e "\tnamed 05-vscode, build scripts should be in the following"
        echo -e "\tpath: ${LIGHTYELLOW}$CURRENT_DIR/modules/05-vscode${ENDCOLOR}"
        echo -e "Examples:"
        echo -e "\t${LIGHTYELLOW}$0 build_modules ${ENDCOLOR} build modules"
        echo -e "\t${LIGHTYELLOW}$0 repack_modules ${ENDCOLOR} repack the system with the"
        echo -e "\tcompression type specified by /etc/$LIVEKITNAME/config in COMP_TYPE variable"
        echo -e "\t${LIGHTYELLOW}$0 - ${ENDCOLOR} this command will run both functions alternately"
        exit 0
    fi
}

function read_cmdline() {
    for i in $@; do
        case $i in
        user_name=*)
            USER_NAME="${i#*=}"
            shift # past argument=value
            ;;
        user_password=*)
            USER_PASSWORD="${i#*=}"
            shift # past argument=value
            ;;
        root_password=*)
            ROOT_PASSWORD="${i#*=}"
            shift # past argument=value
            ;;
        host_name=*)
            HOST_NAME="${i#*=}"
            shift # past argument=value
            ;;
        default_target=*)
            DEFAULT_TARGET="${i#*=}"
            shift # past argument=value
            ;;
        text)
            TEXT_MODE="true"
            shift # past argument with no value
            ;;
        enable_services=*)
            ENABLE_SERVICES="${i#*=}"
            shift # past argument=value
            ;;
        disable_services=*)
            DISABLE_SERVICES="${i#*=}"
            shift # past argument=value
            ;;
        ssh_key=*)
            SSH_KEY="${i#*=}"
            shift # past argument=value
            ;;
        $LIVEKITNAME.flags=*)
            FLAGS="${i#*=}"
            shift # past argument=value
            ;;
        slax.flags=*)
            SFLAGS="${i#*=}"
            shift # past argument=value
            ;;
        toram)
            TORAM="true"
            shift # past argument with no value
            ;;
        perchdir=*)
            PERCHDIR="${i#*=}"
            shift # past argument=value
            ;;
        scripts=*)
            SCRIPTS="${i#*=}"
            shift # past argument=value
            ;;
        cloud)
            CLOUD="true"
            shift # past argument with no value
            ;;
        hide_credentials)
            HIDE_CREDENTIALS="true"
            shift # past argument with no value
            ;;
        static_profiles)
            STATIC_PROFILES="true"
            shift # past argument with no value
            ;;
        autologin=*)
            AUTOLOGIN="${i#*=}"
            shift # past argument=value
            ;;
        system_type=*)
            SYSTEM_TYPE="${i#*=}"
            shift # past argument=value
            ;;
        from=*)
            FROM="${i#*=}"
            shift # past argument=value
            ;;
        *)
            UNKNOWN="true"
            # unknown option
            ;;
        esac
    done
}

# =================================================================
# reading configuration file
# =================================================================

function read_config() {
    # Enable extended globbing. This is required for the pattern matching of variable names.
    shopt -s extglob

    # The first argument is the configuration file.
    local CONFIGFILE="${1?No configuration file given}"

    # All other arguments are the variable names to look for.
    local KEYLIST="${@:2}"

    # Check if the configuration file exists and is readable.
    if [[ ! -f "$CONFIGFILE" ]]; then
        echo >&2 "\"$CONFIGFILE\" is not a file!"
        exit 1
    fi
    if [[ ! -r "$CONFIGFILE" ]]; then
        echo >&2 "\"$CONFIGFILE\" is not readable!"
        exit 1
    fi

    # Convert the list of variable names to a regex pattern.
    KEYLIST="${KEYLIST// /|}"

    # Read each line of the file.
    while IFS='= ' read -r LHS RHS; do
        # If the variable name is in our list and the value is not empty...
        if [[ "$LHS" =~ ^($KEYLIST)$ ]] && [[ -n $RHS ]]; then
            # Remove any quotes around the value.
            RHS="${RHS%\"*}"
            RHS="${RHS#\"*}"
            RHS="${RHS%\'*}"
            RHS="${RHS#\'*}"

            # If the value is an array (surrounded by parentheses)...
            if [[ "$RHS" =~ ^\((.*)\)$ ]]; then
                # Assign the array to the variable.
                eval $LHS=\("${BASH_REMATCH[1]}"\)
            else
                # Otherwise, assign the value to the variable.
                eval $LHS=\"$RHS\"
            fi
        fi
    done <<<$(tr -d '\r' <$CONFIGFILE)

    # Disable extended globbing after we're done using it.
    shopt -u extglob
}

function read_config_value() {
    cat $1 | egrep -o "(^|[[:space:]])$2=[^[:space:]]+" | tr -d " " | cut -d "=" -f 2- | tail -n 1
}

# =================================================================
# parsing input commands
# =================================================================

function find_index() {
    local ret
    local i
    for ((i = 0; i < ${#CMD[*]}; i++)); do
        if [ "${CMD[i]}" == "$1" ]; then
            index=$i
            return
        fi
    done
    help "Command not found : $1"
}

# =================================================================
# creating a symbolic link to the executable file for using
# autocompletion on the command line
# =================================================================

function create_livekitname_install_symlink() {
    if [ -L /usr/bin/$LIVEKITNAME-install ]; then
        if [ "$(readlink /usr/bin/$LIVEKITNAME-install)" != "$SCRIPT_DIR/install" ]; then
            rm -f /usr/bin/$LIVEKITNAME-install
            ln -s $SCRIPT_DIR/install /usr/bin/$LIVEKITNAME-install
            echo -e "The ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOR} symbolic link has been updated."
            echo -e "It now points to ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOR}."
        fi
        if [ "$0" != "/usr/bin/$LIVEKITNAME-install" ]; then
            echo -e "You can use the ${CYAN}$LIVEKITNAME-install${ENDCOLOR} command to run this program."
        fi
    else
        ln -s $SCRIPT_DIR/install /usr/bin/$LIVEKITNAME-install
        echo -e "The ${MAGENTA}/usr/bin/$LIVEKITNAME-install${ENDCOLOR} symbolic link has been added"
        echo -e "for ${MAGENTA}$SCRIPT_DIR/install${ENDCOLOR}."
    fi
}

# =================================================================
# creating autocompletion on the command line
# =================================================================

function create_completion() {
    if [ -d /etc/bash_completion.d ]; then
        for cmd in $LIVEKITNAME-install minios-modules; do
            if [ ! -f /etc/bash_completion.d/$cmd ] || ! grep "${CMD[*]}" /etc/bash_completion.d/$cmd >/dev/null 2>&1; then
                cat <<EOF >/etc/bash_completion.d/$cmd
#!/usr/bin/env bash
complete -W "${CMD[*]}" $cmd
EOF
            fi
        done
    fi
}

# =================================================================
# only allow 'root' to run the script
# =================================================================

function allow_root_only() {
    if [ $(id -u) -ne 0 ]; then
        echo -e "${BOLD}${RED}This script should be run as 'root'!${ENDCOLOR}"
        exit 1
    fi

    export HOME=/root
    export LC_ALL=C
}

# =================================================================
# check that we are inside chroot
# =================================================================

function check_is_in_chroot() {
    if [ $(stat -c %i /)="2" ]; then
        echo -e "${BOLD}${RED}This script should be run inside chroot only!${ENDCOLOR}"
        exit 1
    fi
}

# =================================================================
# check aufs support
# =================================================================

function aufs_support() {
    if ! cat /proc/filesystems | grep aufs >/dev/null; then
        UNION_BUILD_TYPE="overlayfs"
    else
        UNION_BUILD_TYPE="aufs"
    fi
}

# =================================================================
# check if filesystems are unmounted inside chroot
# =================================================================

function check_mounted() {
    current_function
    if grep -qs "$INSTALL_DIR/dev" /proc/mounts || grep -qs "$INSTALL_DIR/run" /proc/mounts || grep -qs "$INSTALL_DIR/proc" /proc/mounts || grep -qs "$INSTALL_DIR/sys" /proc/mounts || grep -qs "$INSTALL_DIR/dev/pts" /proc/mounts || grep -qs "$INSTALL_DIR/tmp" /proc/mounts; then
        echo -e "${BOLD}${LIGHTYELLOW}Сhroot contains mounted filesystems.${ENDCOLOR}"
        if [ "$UNATTENDED" = "true" ]; then
            chroot_umount_fs
        else
            read -r -p "$(echo -e ""Do you want to ${GREEN}unmount them${ENDCOLOR}? [${BOLD}${GREEN}Y${ENDCOLOR}/n])" response
            response=${response,,}
            if [[ "$response" =~ ^(no|n)$ ]]; then
                exit 1
            else
                chroot_umount_fs
            fi
        fi
    fi
}

# =================================================================
# check if the folder where the installation will be performed is empty
# =================================================================

function check_install_dir() {
    current_function
    if [ "$UNATTENDED" = "true" ]; then
        #echo -e "${RED}!!!Unattended installation!!!${ENDCOLOR}"
        #INSTALL_DIR="$BUILD_DIR/$DISTRIBUTION-$DISTRIBUTION_ARCH"
        INSTALL_DIR="$WORK_DIR/basesystem"
        echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOR}."
        if [ "$(ls -A $INSTALL_DIR 2>/dev/null)" != "" ]; then
            cleanup
            check_mounted
        fi
    else
        if [ "$(ls -A $INSTALL_DIR 2>/dev/null)" != "" ]; then
            echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOR} is not empty."
            cleanup
            check_mounted
            if [ ! -d "$INSTALL_DIR" ]; then
                mkdir -p $INSTALL_DIR
            fi
            INSTALL_DIR="$(
                cd $INSTALL_DIR
                pwd
            )"
            echo $INSTALL_DIR >$SCRIPT_DIR/.install_dir && chmod 644 $SCRIPT_DIR/.install_dir
            echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOR}."
        else
            mkdir -p $INSTALL_DIR
            check_mounted
            INSTALL_DIR="$(
                cd $INSTALL_DIR
                pwd
            )"
            echo $INSTALL_DIR >$SCRIPT_DIR/.install_dir && chmod 644 $SCRIPT_DIR/.install_dir
            echo -e "The working directory is ${MAGENTA}$INSTALL_DIR${ENDCOLOR}."
        fi
    fi
}

# =================================================================
# configure build folder
# =================================================================

function setup_install_dir() {
    current_function
    WORK_DIR="$BUILD_DIR/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH"
    if [ "$UNATTENDED" = "true" ] && [ "$INSTALL_DIR" = "" ]; then
        INSTALL_DIR="$WORK_DIR/basesystem"
        check_install_dir
    else
        if [ "$INSTALL_DIR" = "" ]; then
            if [ ! -f "$SCRIPT_DIR/.install_dir" ]; then
                echo "Enter the address of the working directory where we will build the system"
                read -r -p "$(echo -e "(Default is ${MAGENTA}$WORK_DIR/basesystem${ENDCOLOR}): ")" response
                INSTALL_DIR=${response,,}
                if [ "$INSTALL_DIR" = "" ]; then
                    INSTALL_DIR="$WORK_DIR/basesystem"
                fi
                check_install_dir
            else
                LAST_INSTALL_DIR=$(cat "$SCRIPT_DIR/.install_dir")
                echo -e "Last time you used the build directory ${MAGENTA}$LAST_INSTALL_DIR${ENDCOLOR}."
                read -r -p "$(echo -e ""Do you want to use it again? [${BOLD}${GREEN}Y${ENDCOLOR}/n])" response
                response=${response,,}
                if [[ "$response" =~ ^(no|n)$ ]]; then
                    echo "Enter the address of the working directory where we will build the system"
                    read -r -p "$(echo -e "(Default is ${MAGENTA}$WORK_DIR/basesystem${ENDCOLOR}): ")" response
                    INSTALL_DIR=${response,,}
                    if [ "$INSTALL_DIR" = "" ]; then
                        INSTALL_DIR="$WORK_DIR/basesystem"
                    fi
                    check_install_dir
                else
                    INSTALL_DIR="$LAST_INSTALL_DIR"
                    check_install_dir
                fi
            fi
        fi
    fi
}

# =================================================================
# cleaning the build folder
# =================================================================

function cleanup() {
    current_function
    if [ "${CMD[ii]}" = "setup_host" ] || [ "${CMD[ii]}" = "build_bootstrap" ] || [ "${CMD[ii]}" = "build_chroot" ]; then
        if [ "$UNATTENDED" = "true" ]; then
            check_mounted
            rm -rf $INSTALL_DIR
            if [ -d "$INSTALL_DIR" ]; then
                cleanup
            fi
        else
            read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOR} of ${MAGENTA}$INSTALL_DIR${ENDCOLOR}? [y/${BOLD}${GREEN}N${ENDCOLOR}])" response
            response=${response,,}
            if [[ "$response" =~ ^(yes|y)$ ]]; then
                check_mounted
                rm -rf $INSTALL_DIR
                if [ -d "$INSTALL_DIR" ]; then
                    cleanup
                fi
            else
                echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOR} should be empty to continue."
                exit 1
            fi
        fi
    elif [ "${CMD[ii]}" = "remove_sources" ]; then
        if [ $REMOVE_SOURCES = "true" ]; then
            if [ "$UNATTENDED" = "true" ]; then
                check_mounted
                rm -rf $WORK_DIR
                if [ -d "$WORK_DIR" ]; then
                    cleanup
                fi
            else
                read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOR} of ${MAGENTA}$WORK_DIR{ENDCOLOR}? [y/${BOLD}${GREEN}N${ENDCOLOR}])" response
                response=${response,,}
                if [[ "$response" =~ ^(yes|y)$ ]]; then
                    check_mounted
                    rm -rf $WORK_DIR
                    if [ -d "$WORK_DIR" ]; then
                        cleanup
                    fi
                else
                    echo -e "${MAGENTA}$INSTALL_DIR${ENDCOLOR} should be empty to continue."
                    exit 1
                fi
            fi
        fi
    fi

}

# =================================================================
# mount filesystems inside chroot
# =================================================================

function chroot_mount_fs() {
    current_function

    check_mounted

    if [ -f /.dockerenv ] || [ "$container" = "podman" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        if [ -L $INSTALL_DIR/etc/resolv.conf ] || [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
            if [ -e $INSTALL_DIR/etc/resolv.conf ]; then
                mv $INSTALL_DIR/etc/resolv.conf $INSTALL_DIR/etc/resolv.conf.bak
            fi
            echo "nameserver 8.8.8.8" >>$INSTALL_DIR/etc/resolv.conf
        elif [ ! -e $INSTALL_DIR/etc/resolv.conf ]; then
            echo "nameserver 8.8.8.8" >>$INSTALL_DIR/etc/resolv.conf
        fi
    fi

    mount --bind /dev $INSTALL_DIR/dev
    mount --bind /run $INSTALL_DIR/run
    if [ $DISTRIBUTION = "stretch" ]; then
        mount --bind /proc $INSTALL_DIR/proc
    else
        mount none -t proc $INSTALL_DIR/proc
    fi
    mount none -t sysfs $INSTALL_DIR/sys
    mount none -t devpts $INSTALL_DIR/dev/pts
    mount none -t tmpfs $INSTALL_DIR/tmp
    if [ ! -d $SCRIPT_DIR/aptcache/$DISTRIBUTION ]; then
        mkdir -p $SCRIPT_DIR/aptcache/$DISTRIBUTION
    fi
    if [ ! -d $INSTALL_DIR/var/cache/apt/archives ]; then
        mkdir -p $INSTALL_DIR/var/cache/apt/archives
    fi
    mount --bind $SCRIPT_DIR/aptcache/$DISTRIBUTION $INSTALL_DIR/var/cache/apt/archives
}

# =================================================================
# unmount filesystems inside chroot
# =================================================================

function chroot_umount_fs() {
    current_function

    set +e

    for dir in var/cache/apt/archives proc sys dev/pts tmp dev run; do
        umount "$INSTALL_DIR/$dir"
    done

    if [ -f /.dockerenv ] || [ "$container" = "podman" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        if [ -L $INSTALL_DIR/etc/resolv.conf.bak ] || [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "focal" ]; then
            rm -f $INSTALL_DIR/etc/resolv.conf
            mv $INSTALL_DIR/etc/resolv.conf.bak $INSTALL_DIR/etc/resolv.conf
        elif [ -L $INSTALL_DIR/etc/resolv.conf.bak ] && [ -L $INSTALL_DIR/etc/resolv.conf ]; then
            rm -f $INSTALL_DIR/etc/resolv.conf.bak
        elif [ -e $INSTALL_DIR/etc/resolv.conf ] && [ $DISTRIBUTION_TYPE = "bionic" ]; then
            rm -f $INSTALL_DIR/etc/resolv.conf
        fi
    fi
    set -e

    check_mounted
}

function add_unofficial_repository() {
    current_function
    if [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ]; then
        if [ $USE_UNOFFICIAL_REPOSITORY = "true" ]; then
            cat <<EOF >$INSTALL_DIR/etc/apt/sources.list
deb $UNOFFICIAL_REPOSITORY_ADDRESS $DISTRIBUTION main contrib non-free
EOF
        fi
    fi
}

function remove_unofficial_repository() {
    current_function
    if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
        cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list $INSTALL_DIR/etc/apt/sources.list
    else
        cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
    fi
}

# =================================================================
# Displaying information about the start of the build for a more
# convenient search in the logs
# =================================================================

function new_run() {
    DATE=$(date +"%Y.%m.%d %H:%M")
    echo ""
    echo "================================================================="
    echo "================================================================="
    echo "============================ NEW RUN ============================"
    echo "======================== $DATE ======================="
    echo "================================================================="
    echo "======= If during the installation you get an error that ========"
    echo "=== /dev/stdout is not available, try using a bionic or xenial =="
    echo "================= based container to install. ==================="
    echo "================================================================="
    echo "================================================================="
    echo "========== Distributution: $DISTRIBUTION"
    echo "========== Desktop environment: $DESKTOP_ENVIRONMENT"
    echo "========== Package variant: $PACKAGE_VARIANT"
    echo "========== Arch: $DISTRIBUTION_ARCH"
    echo "========== Initrd type: $INITRD_TYPE"
    echo "========== Kernel type: $KERNEL_TYPE"
    echo "========== Kernel BPO: $KERNEL_BPO"
    echo "========== Kernel AUFS: $KERNEL_AUFS"
    echo "========== Install additional drivers: $KERNEL_BUILD_DKMS"
    echo "========== Named boot files: $NAMED_BOOT_FILES"
    echo "========== Compression: $COMP_TYPE"
    echo "========== Locale: $LOCALE"
    echo "========== Time zone: $TIMEZONE"
    echo "================================================================="
    echo "================================================================="
    echo ""
}
# =================================================================
# This function creates two configuration files for chroot environment
# The first file contains various environment variables and their values
# The second file contains several utility functions
# =================================================================
function add_chroot_configuration_files() {
    cat <<EOF >$1/$LIVEKITNAME.conf
BUILD_TEST_ISO="$BUILD_TEST_ISO"
DEBIAN_FRONTEND_TYPE="$DEBIAN_FRONTEND_TYPE"
DESKTOP_ENVIRONMENT="$DESKTOP_ENVIRONMENT"
DISTRIBUTION="$DISTRIBUTION"
DISTRIBUTION_TYPE="$DISTRIBUTION_TYPE"
PACKAGE_VARIANT="$PACKAGE_VARIANT"
COMP_TYPE="$COMP_TYPE"
INITRD_TYPE="$INITRD_TYPE"
#KERNEL=\$KERNEL
KERNEL_VERSION="$KERNEL_VERSION"
KERNEL_ARCH="$KERNEL_ARCH"
KERNEL_TYPE="$KERNEL_TYPE"
KERNEL_BPO="$KERNEL_BPO"
KERNEL_AUFS="$KERNEL_AUFS"
KERNEL_BUILD_DKMS="$KERNEL_BUILD_DKMS"
LIVEKITNAME="$LIVEKITNAME"
SYSTEMNAME="$SYSTEMNAME"
DISTRIBUTION_ARCH="$DISTRIBUTION_ARCH"
LOCALE="$LOCALE"
LOCALES=(${LOCALES[@]})
MULTILINGUAL="$MULTILINGUAL"
LAYOUT="$LAYOUT"
LAYOUTCODE="$LAYOUTCODE"
TIMEZONE="$TIMEZONE"
MODULE="$MODULE"
USER_NAME="$USER_NAME"
BEXT="$BEXT"
EOF

    if [ -f $SCRIPT_DIR/linux-live/minioslib ]; then
        cp $SCRIPT_DIR/linux-live/minioslib $1/minioslib
    elif [ -f /linux-live/minioslib ]; then
        cp /linux-live/minioslib $1/minioslib
    elif [ -f /usr/lib/minioslib ]; then
        cp /usr/lib/minioslib $1/minioslib
    fi
}

function remove_chroot_configuration_files() {
    rm -f $1/$LIVEKITNAME.conf
    rm -f $1/functions
    rm -f $1/minioslib
}

function get_latest_release() {
    curl --silent "https://api.github.com/repos/$1/releases/latest" | # Get latest release from GitHub api
        grep '"tag_name":' |                                          # Get tag line
        sed -E 's/.*"([^"]+)".*/\1/'                                  # Pluck JSON value
}

function get_latest_package_url() {
    curl --silent "https://api.github.com/repos/$1/releases/latest" | # Get latest release from GitHub api
        grep '"browser_download_url":' | grep ".sb"\" |               # Get tag line
        sed -E 's/.*"([^"]+)".*/\1/'                                  # Pluck JSON value
}

function timezone_to_array() {
    local IFS
    IFS="/"
    TIMEZONE=($TIMEZONE)
}

function pkg() {
    local PACKAGE_MANAGER INSTALL_OPTIONS

    if command -v apt-get >/dev/null 2>&1; then
        PACKAGE_MANAGER="apt-get"
    elif command -v apt >/dev/null 2>&1; then
        PACKAGE_MANAGER="apt"
    elif command -v dnf >/dev/null 2>&1; then
        PACKAGE_MANAGER="dnf"
    elif command -v yum >/dev/null 2>&1; then
        PACKAGE_MANAGER="yum"
    else
        echo "Error: Could not find a supported package manager" >&2
        exit 1
    fi

    case "$PACKAGE_MANAGER" in
    apt-get | apt | dnf | yum)
        INSTALL_OPTIONS="--yes"
        ;;
    esac

    local COMMAND="$1"
    shift

    case "$COMMAND" in
    install | remove | update | upgrade | autoremove | purge | clean | build-dep | source)
        if [ "$PACKAGE_MANAGER" = "apt-get" ] || [ "$PACKAGE_MANAGER" = "apt" ]; then
            DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE $PACKAGE_MANAGER $INSTALL_OPTIONS "$COMMAND" "$@"
        else
            $PACKAGE_MANAGER $INSTALL_OPTIONS "$COMMAND" "$@"
        fi
        ;;
    update)
        if [ "$PACKAGE_MANAGER" = "apt-get" ] || [ "$PACKAGE_MANAGER" = "apt" ]; then
            DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE $PACKAGE_MANAGER $INSTALL_OPTIONS "$COMMAND"
        else
            $PACKAGE_MANAGER $INSTALL_OPTIONS "$COMMAND"
        fi
        ;;
    *)
        echo "Invalid command: $COMMAND" >&2
        exit 1
        ;;
    esac
}

# =================================================================
# =================================================================
# ====================== HOST FUNCTIONS ===========================
# =================================================================
# =================================================================

# =================================================================
# Creating a $PACKAGE_VARIANT list from a template
# =================================================================

function create_apt_list() {
    current_function
    if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
        if [ $DISTRIBUTION = "sid" ] || [ $DISTRIBUTION = "bookworm" ]; then
            echo "deb     https://snapshot.debian.org/archive/debian/$SNAPSHOT_DATE/ $DISTRIBUTION main contrib non-free" >$SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list
            echo "#deb-src https://snapshot.debian.org/archive/debian/$SNAPSHOT_DATE/ $DISTRIBUTION main contrib non-free" >>$SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list
        else
            cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION_TYPE-snapshot.list $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list
            sed -i "s,distro,$DISTRIBUTION,g;s,datetime,$SNAPSHOT_DATE,g" $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list
        fi
    else
        if [ ! -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list ]; then
            if [ $DISTRIBUTION_TYPE = "debian" ] && [[ $DISTRIBUTION = "stretch" || $DISTRIBUTION = "buster" ]]; then
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION_TYPE-old.list $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
            else
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION_TYPE.list $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
            fi
            sed -i "s,distro,$DISTRIBUTION,g" $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
            sed -i "s,http://archive.ubuntu.com/ubuntu,$DISTRIBUTION_URL,g" $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list
        fi
    fi
}

function get_vars() {
    current_function
    set +u
    add_chroot_configuration_files $1
    . /minioslib
    read_config /$LIVEKITNAME.conf $VARIABLES
    export $VARIABLES
    set -u
}

function chroot_run() {
    current_function
    add_chroot_configuration_files $1
    chroot $1 /bin/bash <<EOF
. /minioslib
read_config /$LIVEKITNAME.conf $VARIABLES
export $VARIABLES
${@:2}
EOF
    remove_chroot_configuration_files $1
}

# Unzip gzipped files (man pages), so LZMA can compress 2times better.
# First we fix symlinks, then uncompress files
# $1 = search directory
uncompress_files() {
    current_function
    local LINK LINE

    find "$1" -type l -name "*.gz" | while read LINE; do
        LINK="$(readlink "$LINE" | sed -r 's/.gz$//')"
        FILE="$(echo "$LINE" | sed -r 's/.gz$//')"
        ln -sfn "$LINK" "$FILE"
        rm -f "$LINE"
    done
    find "$1" -type f -name "*.gz" | xargs -r gunzip 2>/dev/null
}

# remove broken links
# $1 = search directory
remove_broken_links() {
    current_function
    find "$1" -type l -exec test ! -e {} \; -print | xargs rm -vf
}

# =================================================================
# Installing the base system
# =================================================================

function build_bootstrap() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi
    if [ $USE_ROOTFS = "true" ] && [ ! -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
        if [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz ]; then
            if [ ! -d $INSTALL_DIR ]; then
                mkdir -p $INSTALL_DIR
            fi
            tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR
        else
            if [ ! -d "$SCRIPT_DIR/aptcache/$DISTRIBUTION" ]; then
                mkdir -p "$SCRIPT_DIR/aptcache/$DISTRIBUTION"
            fi
            if [ ! -d "$INSTALL_DIR/var/cache/apt/archives" ]; then
                mkdir -p "$INSTALL_DIR/var/cache/apt/archives"
            fi
            mount --bind "$SCRIPT_DIR/aptcache/$DISTRIBUTION" "$INSTALL_DIR/var/cache/apt/archives"
            if [ $DISTRIBUTION = "orel" ]; then
                if [ ! -L /usr/share/debootstrap/scripts/orel ]; then
                    ln -s sid /usr/share/debootstrap/scripts/orel
                fi
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH --include=apt-transport-https --exclude=usr-is-merged $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
            elif [ $PACKAGE_VARIANT = "minimum1" ] || [ $PACKAGE_VARIANT = "cloud1" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH --variant=minbase --include=apt-transport-https $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
            elif [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
            else
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH --include=apt-transport-https $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
            fi
            umount "$INSTALL_DIR/var/cache/apt/archives"
            if [ ! -d $SCRIPT_DIR/rootfs ]; then
                mkdir -p $SCRIPT_DIR/rootfs
            fi
            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR .
        fi
    elif [ $USE_ROOTFS = "true" ] && [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
        if [ ! -d $INSTALL_DIR ]; then
            mkdir -p $INSTALL_DIR
        fi
        tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz -C $INSTALL_DIR
    elif [ $USE_ROOTFS != "true" ] && [ $USE_BOOTSTRAP = "true" ]; then
        if [ -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz ]; then
            if [ ! -d $INSTALL_DIR ]; then
                mkdir -p $INSTALL_DIR
            fi
            tar -xzf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR
        else
            if [ $DISTRIBUTION = "orel" ]; then
                cd /usr/share/debootstrap/scripts
                ln -s sid orel
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
            elif [ $PACKAGE_VARIANT = "minimum1" ] || [ $PACKAGE_VARIANT = "cloud1" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH --variant=minbase --include=apt-transport-https $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
            elif [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
            else
                sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                    debootstrap --arch=$DISTRIBUTION_ARCH --include=apt-transport-https $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
            fi
            if [ ! -d $SCRIPT_DIR/rootfs ]; then
                mkdir -p $SCRIPT_DIR/rootfs
            fi
            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH.tar.gz -C $INSTALL_DIR .
        fi
    else
        if [ $DISTRIBUTION = "orel" ]; then
            cd /usr/share/debootstrap/scripts
            ln -s sid orel
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --keyring $SCRIPT_DIR/linux-live/basesystem/gpg/astra-archive.gpg --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
        elif [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --arch=$DISTRIBUTION_ARCH $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
        elif [ $PACKAGE_VARIANT = "minimum1" ] || [ $PACKAGE_VARIANT = "cloud1" ]; then
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --arch=$DISTRIBUTION_ARCH --variant=minbase --include=apt-transport-https $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
        else
            sudo DEBIAN_FRONTEND=$DEBIAN_FRONTEND_TYPE \
                debootstrap --arch=$DISTRIBUTION_ARCH --include=apt-transport-https $DISTRIBUTION $INSTALL_DIR $DISTRIBUTION_URL
        fi
    fi

    build_rootfs

}

function mx_repo() {
    current_function
    if [ $USE_MX_REPO = "true" ]; then
        if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ]; then
            cd $INSTALL_DIR
            wget http://mxrepo.com/mx/repo/pool/main/m/mx-archive-keyring/mx-archive-keyring_2018.2mx17_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/m/mx19-archive-keyring/mx19-archive-keyring_2020.4.29_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/m/mx21-archive-keyring/mx21-archive-keyring_2021.2.19_all.deb
            wget https://mxrepo.com/mx/repo/pool/main/a/antix-archive-keyring/antix-archive-keyring_20019.5.0_all.deb
            chroot_run $INSTALL_DIR pkg install /*.deb
            rm $INSTALL_DIR/*.deb
            cat <<EOF >$INSTALL_DIR/etc/apt/sources.list.d/mx.list
# MX Community Main and Test Repos
deb http://mxrepo.com/mx/repo/ $DISTRIBUTION main non-free
#deb http://mxrepo.com/mx/testrepo/ $DISTRIBUTION test

#ahs hardware stack repo
deb http://mxrepo.com/mx/repo/ $DISTRIBUTION ahs
EOF
        fi
    fi
}

function antix_repo() {
    current_function
    if [ $USE_ANTIX_REPO = "true" ]; then
        if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ]; then
            cd $INSTALL_DIR
            wget http://mxrepo.com/mx/repo/pool/main/m/mx-archive-keyring/mx-archive-keyring_2018.2mx17_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/m/mx19-archive-keyring/mx19-archive-keyring_2020.4.29_all.deb
            wget http://mxrepo.com/mx/repo/pool/main/m/mx21-archive-keyring/mx21-archive-keyring_2021.2.19_all.deb
            wget https://mxrepo.com/mx/repo/pool/main/a/antix-archive-keyring/antix-archive-keyring_20019.5.0_all.deb
            chroot_run $INSTALL_DIR pkg install /*.deb
            rm $INSTALL_DIR/*.deb
            cat <<EOF >$INSTALL_DIR/etc/apt/sources.list.d/antix.list
# antiX Community Repos
deb http://mirror.yandex.ru/mirrors/MX-Linux/MX-Packages/antix/$DISTRIBUTION/ $DISTRIBUTION main nonfree
EOF
        fi
    fi
}

function mint_repo() {
    current_function
    if [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
        if [ $DISTRIBUTION = "jammy" ]; then
            cd $INSTALL_DIR
            wget http://packages.linuxmint.com/pool/main/l/linuxmint-keyring/linuxmint-keyring_2022.06.21_all.deb
            chroot_run $INSTALL_DIR pkg install /*.deb
            rm $INSTALL_DIR/*.deb
            if [ $DISTRIBUTION = "focal" ]; then
                cat <<EOF >$INSTALL_DIR/etc/apt/sources.list.d/linux-mint.list
deb http://packages.linuxmint.com una main upstream import backport #id:linuxmint_main
EOF
            elif [ $DISTRIBUTION = "jammy" ]; then
                cat <<EOF >$INSTALL_DIR/etc/apt/sources.list.d/linux-mint.list
deb http://packages.linuxmint.com vera main upstream import backport #id:linuxmint_main
EOF
            fi
        fi
    fi
}

function build_rootfs() {
    current_function

    if [ $USE_ROOTFS = "true" ]; then
        if [ ! -f $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz ]; then
            if [ $CONTAINER_TYPE = "1" ]; then
                if [ ! -f /.minios-live ]; then
                    setup_host
                fi
            fi

            chroot_mount_fs

            cat <<'EOF' >$INSTALL_DIR/etc/apt/apt.conf.d/000MiniOS
APT::Install-Recommends "0";
APT::Install-Suggests "0";
Acquire::Languages { "none"; }
EOF

            if [ $DISTRIBUTION = "kali-rolling" ]; then
                DISTRIBUTION="testing"
                create_apt_list
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
                chroot_run $INSTALL_DIR pkg update
                chroot_run $INSTALL_DIR pkg install gnupg
                chroot_run $INSTALL_DIR apt-key adv --keyserver keyserver.ubuntu.com --recv-keys ED444FF07D8D0BF6
                DISTRIBUTION="kali-rolling"
            fi

            create_apt_list

            chroot_run $INSTALL_DIR pkg update
            chroot_run $INSTALL_DIR pkg install gnupg ca-certificates
            if [ $DISTRIBUTION = "orel" ]; then
                cd $INSTALL_DIR
                wget https://dl.astralinux.ru/astra/stable/2.12_x86-64/repository/pool/non-free/libg/libgost/libgost_2.0.2-5+ci2_amd64.deb
                chroot_run $INSTALL_DIR pkg install ./libgost_2.0.2-5+ci2_amd64.deb
                rm $INSTALL_DIR/libgost_2.0.2-5+ci2_amd64.deb
                cd -
            fi

            if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list $INSTALL_DIR/etc/apt/sources.list
                echo 'Acquire::Check-Valid-Until "false";' | sudo tee $INSTALL_DIR/etc/apt/apt.conf.d/00snapshot
            else
                cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
            fi

            mx_repo
            antix_repo

            chroot_run $INSTALL_DIR pkg update
            chroot_run $INSTALL_DIR pkg upgrade

            if [ -f $SCRIPT_DIR/linux-live/package_lists/prerequisites.list ]; then
                chroot_run $INSTALL_DIR pkg install \
                    $(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/package_lists/prerequisites.list | tr "\n" " ")
            fi

            chroot_umount_fs

            tar -czf $SCRIPT_DIR/rootfs/$DISTRIBUTION-$DISTRIBUTION_ARCH-rootfs.tar.gz -C $INSTALL_DIR .
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function copy_build_scripts() {
    current_function

    local DESTINATION
    set +u
    if [ -z $1 ]; then
        DESTINATION=$INSTALL_DIR
    else
        DESTINATION=$1
    fi
    set -u
    if [ ! -d $DESTINATION/linux-live ]; then
        mkdir -p $DESTINATION/linux-live
        (cd $SCRIPT_DIR/linux-live && cp --parents -afr * $DESTINATION/linux-live)
    else
        find $SCRIPT_DIR/linux-live -type f -not -path "*.git/*" -print0 | sed "s,$SCRIPT_DIR/linux-live/,,g" | while IFS= read -r -d '' file; do
            if ! cmp $SCRIPT_DIR/linux-live/"$file" $DESTINATION/linux-live/"$file"; then
                echo -e "$file has been modified since last build run."
                echo -e "Copying $SCRIPT_DIR/linux-live/$file to $DESTINATION/linux-live/$file..."
                cp -f $SCRIPT_DIR/linux-live/"$file" $DESTINATION/linux-live/"$file"
            fi
        done
    fi

    chmod +x $DESTINATION/linux-live/install_chroot

    if [ "$DEV_SYSTEM" = "true" ]; then
        if [ ! -d $DESTINATION/opt/minios-live ]; then
            mkdir -p $DESTINATION/opt/minios-live
            (cd $SCRIPT_DIR && cp --parents -afr * $DESTINATION/opt/minios-live)
        else
            find $SCRIPT_DIR/linux-live -type f -print0 | sed "s,$SCRIPT_DIR/linux-live/,,g" | while IFS= read -r -d '' file; do
                if ! cmp $SCRIPT_DIR/"$file" $DESTINATION/opt/minios-live/"$file"; then
                    echo -e "$file has been modified since last build run."
                    echo -e "Copying $SCRIPT_DIR/$file to $DESTINATION/opt/minios-live/$file..."
                    cp -f $SCRIPT_DIR/"$file" $DESTINATION/opt/minios-live/"$file"
                fi
            done
        fi
    elif [ $DOWNLOAD_SOURCES = "true" ]; then
        if [ ! -d $DESTINATION/opt/minios-live ]; then
            mkdir -p $DESTINATION/opt
            cd $DESTINATION/opt
            git clone --depth=1 https://github.com/minios-linux/minios-live.git
            if [ -d $DESTINATION/opt/minios-live/.git ]; then
                rm -rf $DESTINATION/opt/minios-live/.git
            fi
            if [ -f $DESTINATION/opt/minios-live/.gitignore ]; then
                rm -f $DESTINATION/opt/minios-live/.gitignore
            fi
        fi
    fi

    if [ -d $DESTINATION/opt/minios-live/.git ]; then
        rm -rf $DESTINATION/opt/minios-live/.git
    fi
    if [ -f $DESTINATION/opt/minios-live/.gitignore ]; then
        rm -f $DESTINATION/opt/minios-live/.gitignore
    fi

}

# =================================================================
#
# =================================================================
function build_chroot() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    chroot_mount_fs

    copy_build_scripts

    create_apt_list

    if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
        cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION-snapshot.list $INSTALL_DIR/etc/apt/sources.list
    else
        cp -f $SCRIPT_DIR/linux-live/aptsources/$DISTRIBUTION.list $INSTALL_DIR/etc/apt/sources.list
    fi

    VANILLA_ASTRA="true"
    if [ $DISTRIBUTION = "orel" ]; then
        if [ $VANILLA_ASTRA != "true" ]; then
            cat $SCRIPT_DIR/linux-live/aptsources/stretch.list | sed '/backports/d' >$INSTALL_DIR/etc/apt/sources.list.d/stretch.list
        fi
    fi

    add_unofficial_repository

    if [ -f /.minios-live-container ]; then
        chroot_run $INSTALL_DIR /linux-live/install_chroot -
    else
        chroot $INSTALL_DIR /linux-live/install_chroot -
    fi

    remove_unofficial_repository

    chroot_umount_fs
}

function mkmod_corefs() {
    local FOLDER
    cd $1
    COREFS=""
    for FOLDER in $MKMOD; do
        if [ -d $1/$FOLDER ]; then
            COREFS="$COREFS $FOLDER"
        fi
    done
}

# =================================================================
#
# =================================================================
function build_live() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    copy_build_scripts

    check_install_dir

    rm -rf $WORK_DIR/image
    mkdir -p $WORK_DIR/image/$LIVEKITNAME/{boot,changes,modules}

    #build_boot

    # create compressed 00-core.sb
    mkmod_corefs $INSTALL_DIR

    if [ $COMP_TYPE = "zstd" ]; then
        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/00-core-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
    elif [ $COMP_TYPE = "xz" ]; then
        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/00-core-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
    else
        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/00-core-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
    fi
}

function build_config() {
    current_process

    if [ -d $WORK_DIR/image/$LIVEKITNAME ]; then
        cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/$LIVEKITNAME.conf
USER_NAME="$USER_NAME"
USER_PASSWORD="$USER_PASSWORD"
ROOT_PASSWORD="$ROOT_PASSWORD"
HOST_NAME="$LIVEKITNAME"
DEFAULT_TARGET="$DEFAULT_TARGET"
ENABLE_SERVICES="$ENABLE_SERVICES"
DISABLE_SERVICES="$DISABLE_SERVICES"
SSH_KEY="$SSH_KEY"
SCRIPTS="$SCRIPTS"
HIDE_CREDENTIALS="$HIDE_CREDENTIALS"
AUTOLOGIN="$AUTOLOGIN"
SYSTEM_TYPE="$SYSTEM_TYPE"
EXPORT_LOGS="$EXPORT_LOGS"
EOF
    fi
}

# =================================================================
#
# =================================================================
function build_boot() {
    current_process

    local OLD_KERNEL

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    copy_build_scripts

    check_install_dir

    cp -r $SCRIPT_DIR/linux-live/bootfiles/* $WORK_DIR/image/$LIVEKITNAME

    if [ $BOOT_TYPE = "hybrid" ]; then
        if [ $DISTRIBUTION_ARCH = "amd64" ]; then
            rm -rf $WORK_DIR/image/$LIVEKITNAME/boot/grub/i386-efi
            rm $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi32.img
            rm $WORK_DIR/image/$LIVEKITNAME/boot/EFI/boot/*32.efi
            mv $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi64.img $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi.img
            cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/EFI/debian/grub.cfg
search --file --set=root /.disk/info
set prefix=(\$root)/minios/boot/grub
source \$prefix/x86_64-efi/grub.cfg
EOF
            cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/grub/x86_64-efi/grub.cfg
insmod part_acorn
insmod part_amiga
insmod part_apple
insmod part_bsd
insmod part_dfly
insmod part_dvh
insmod part_gpt
insmod part_msdos
insmod part_plan
insmod part_sun
insmod part_sunpc
source /$LIVEKITNAME/boot/grub/grub.cfg

EOF
        elif [[ $DISTRIBUTION_ARCH == *"i386"* ]]; then
            rm -rf $WORK_DIR/image/$LIVEKITNAME/boot/grub/x86_64-efi
            rm $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi64.img
            rm $WORK_DIR/image/$LIVEKITNAME/boot/EFI/boot/*64.efi
            mv $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi32.img $WORK_DIR/image/$LIVEKITNAME/boot/grub/efi.img
            cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/EFI/debian/grub.cfg
search --file --set=root /.disk/info
set prefix=(\$root)/minios/boot/grub
source \$prefix/i386-efi/grub.cfg
EOF
            cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/grub/i386-efi/grub.cfg
insmod part_acorn
insmod part_amiga
insmod part_apple
insmod part_bsd
insmod part_dfly
insmod part_dvh
insmod part_gpt
insmod part_msdos
insmod part_plan
insmod part_sun
insmod part_sunpc
source /$LIVEKITNAME/boot/grub/grub.cfg

EOF
        fi

        if [ ! -d $WORK_DIR/image/EFI ]; then
            mkdir -p $WORK_DIR/image/EFI
        fi
        cp -r $WORK_DIR/image/$LIVEKITNAME/boot/EFI/* $WORK_DIR/image/EFI
        if [ ! -d $WORK_DIR/image/.disk ]; then
            mkdir -p $WORK_DIR/image/.disk
        fi
        echo $SYSTEMNAME >$WORK_DIR/image/.disk/info
    else
        rm -rf $WORK_DIR/image/$LIVEKITNAME/boot/grub
        rm -rf $WORK_DIR/image/$LIVEKITNAME/boot/EFI
    fi

    if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ]; then
        DEFAULT_SETTINGS="load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 consoleblank=0 apparmor=0 net.ifnames=0 biosdevname=0"
    else
        DEFAULT_SETTINGS="load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 consoleblank=0 net.ifnames=0 biosdevname=0"
    fi
    if [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ]; then
        DEBUG_SETTINGS="load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 apparmor=0 debug net.ifnames=0 biosdevname=0"
    else
        DEBUG_SETTINGS="load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 debug net.ifnames=0 biosdevname=0"
    fi
    BOOT_SETTINGS="quiet"
    if [ $INITRD_TYPE = "livekit-mos" ]; then
        PERCH_SETTINGS="minios.flags=perch"
        LIVE_SETTINGS="minios.flags="
        RAM_SETTINGS="minios.flags=toram"
    elif [ $INITRD_TYPE = "livekit-slax" ]; then
        PERCH_SETTINGS="slax.flags=perch"
        LIVE_SETTINGS="slax.flags="
        RAM_SETTINGS="slax.flags=toram"
    elif [ $INITRD_TYPE = "uird" ]; then
        if [ $KERNEL_AUFS = "true" ] || ([ $DISTRIBUTION = "bionic" ] || [ $DISTRIBUTION = "focal" ]); then
            PERCH_SETTINGS="uird.mode=changes"
            LIVE_SETTINGS="uird.mode=clean"
            RAM_SETTINGS="uird.copy2ram"
        else
            PERCH_SETTINGS="uird.union=overlay uird.mode=changes"
            LIVE_SETTINGS="uird.union=overlay uird.mode=clean"
            RAM_SETTINGS="uird.union=overlay uird.copy2ram"
        fi
    fi

    FLUX_SETTINGS=""
    ULTRA_SETTINGS=""

    if [ $DESKTOP_ENVIRONMENT = "mediaplayer" ]; then
        BOOT_SETTINGS="hide_credentials"
    elif [ $DESKTOP_ENVIRONMENT = "flux" ]; then
        if [ $INITRD_TYPE = "livekit-mos" ]; then
            PERCH_SETTINGS="minios.flags=perch,automount"
            LIVE_SETTINGS="minios.flags=automount"
            FLUX_SETTINGS=" automount"
        elif [ $INITRD_TYPE = "livekit-slax" ]; then
            PERCH_SETTINGS="slax.flags=perch,automount"
            LIVE_SETTINGS="slax.flags=automount"
            FLUX_SETTINGS=" automount"
        fi
    elif [ $PACKAGE_VARIANT = "ultra" ]; then
        ULTRA_SETTINGS=" apparmor=0 selinux=0"
    fi

    cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
UI /$LIVEKITNAME/boot/vesamenu.c32

PROMPT 0
TIMEOUT 30

MENU CLEAR
MENU HIDDEN
MENU HIDDENKEY Enter default
MENU BACKGROUND /$LIVEKITNAME/boot/bootlogo.png
MENU RESOLUTION 1024 768

MENU WIDTH 125
MENU MARGIN 20
MENU ROWS 5
MENU TABMSGROW 14
MENU CMDLINEROW 12
MENU HSHIFT 0
MENU VSHIFT 32

MENU COLOR BORDER  30;40      #00000000 #00000000 none
MENU COLOR SEL     47;30      #FF000000 #99FFFFFF none
MENU COLOR UNSEL   37;40      #99FFFFFF #FF000000 none
MENU COLOR TABMSG 32;40 #FFA500 #FF000000 none

F1 help.txt /$LIVEKITNAME/boot/zblack.png

MENU AUTOBOOT Press Esc for options, automatic boot in # second{,s} ...
MENU TABMSG [F1] help                                                        [Tab] cmdline >

EOF
    if [ $BOOT_TYPE = "hybrid" ]; then
        cat <<EOF >$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
if loadfont \$prefix/font.pf2 ; then
  set default="0"
  set timeout="3"
  set hidden_timeout_quiet=false
  set gfxmode=auto
  insmod efi_gop
  insmod efi_uga
  insmod video_bochs
  insmod video_cirrus
  insmod gfxterm
  insmod png
  terminal_output gfxterm
fi
set color_normal=white/black
set color_highlight=black/white
background_image \$prefix/bootlogo.png

set default_settings="$DEFAULT_SETTINGS"
set perch_settings="$PERCH_SETTINGS"
set live_settings="$LIVE_SETTINGS"
set ram_settings="$RAM_SETTINGS"
set console_settings="console=tty0 console=ttyS0,115200"
set debug_settings="$DEBUG_SETTINGS"
set linux_image="/$LIVEKITNAME/boot/vmlinuz"
set initrd_img="/$LIVEKITNAME/boot/initrfs.img"
set default=0
set message="Loading kernel and ramdisk..."

EOF
    fi
    if [ $DESKTOP_ENVIRONMENT = "cloud" ] || [ $DESKTOP_ENVIRONMENT = "netdiag" ]; then
        cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >>$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
LABEL default
MENU LABEL Run MiniOS (Copy to RAM)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS console=tty0 console=ttyS0,115200 $BOOT_SETTINGS toram

EOF
        if [ $BOOT_TYPE = "hybrid" ]; then
            cat <<EOF >>$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
menuentry "Run MiniOS (Copy to RAM)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$console_settings $BOOT_SETTINGS toram
    initrd \$initrd_img
}

EOF
            sed -i "s/background_image/#background_image/g" $WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
        fi
    elif [ $DESKTOP_ENVIRONMENT = "mediaplayer" ]; then
        cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >>$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
LABEL default
MENU LABEL Run MiniOS (Copy to RAM)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $RAM_SETTINGS $BOOT_SETTINGS

EOF
        if [ $BOOT_TYPE = "hybrid" ]; then
            cat <<EOF >>$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
menuentry "Run MiniOS (Copy to RAM)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$ram_settings $BOOT_SETTINGS
    initrd \$initrd_img
}

EOF
        fi
    elif [ $INITRD_TYPE = "uird" ]; then
        cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >>$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
LABEL default
MENU LABEL Run MiniOS (Persistent changes)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $PERCH_SETTINGS $BOOT_SETTINGS

LABEL live
MENU LABEL Run MiniOS (Fresh start)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $LIVE_SETTINGS $BOOT_SETTINGS

LABEL toram
MENU LABEL Run MiniOS (Copy to RAM)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $RAM_SETTINGS $BOOT_SETTINGS

EOF
        if [ $BOOT_TYPE = "hybrid" ]; then
            cat <<EOF >>$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
menuentry "Run MiniOS (Persistent changes)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$perch_settings $BOOT_SETTINGS
    initrd \$initrd_img
}
menuentry "Run MiniOS (Fresh start)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$live_settings $BOOT_SETTINGS
    initrd \$initrd_img
}
menuentry "Run MiniOS (Copy to RAM)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings \$ram_settings $BOOT_SETTINGS
    initrd \$initrd_img
}

EOF
        fi
    else
        cat <<EOF | iconv -f 'UTF-8' -t "CP866//TRANSLIT" >>$WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
LABEL default
MENU LABEL Run MiniOS (Resume previous session)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS perchdir=resume

LABEL perch
MENU LABEL Run MiniOS (Start a new session)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS perchdir=new

LABEL asksession
MENU LABEL Run MiniOS (Choose session during startup)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS perchdir=ask

LABEL live
MENU LABEL Run MiniOS (Fresh start)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS

LABEL toram
MENU LABEL Run MiniOS (Copy to RAM)
KERNEL /$LIVEKITNAME/boot/vmlinuz
APPEND vga=791 initrd=/$LIVEKITNAME/boot/initrfs.img $DEFAULT_SETTINGS $BOOT_SETTINGS$ULTRA_SETTINGS toram

EOF
        if [ $BOOT_TYPE = "hybrid" ]; then
            cat <<EOF >>$WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
menuentry "Run MiniOS (Resume previous session)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS perchdir=resume
    initrd \$initrd_img
}
menuentry "Run MiniOS (Start a new session)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS perchdir=new
    initrd \$initrd_img
}
menuentry "Run MiniOS (Choose session during startup)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS perchdir=ask
    initrd \$initrd_img
}
menuentry "Run MiniOS (Fresh start)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS
    initrd \$initrd_img
}
menuentry "Run MiniOS (Copy to RAM)"{
    echo \$message
    search --set -f \$linux_image
    linux \$linux_image \$default_settings $BOOT_SETTINGS$FLUX_SETTINGS$ULTRA_SETTINGS toram
    initrd \$initrd_img
}

EOF
        fi
    fi

    cat <<EOF >$WORK_DIR/image/README
################################### README ####################################
* To install MiniOS, copy the contents of the ISO to the root of the media,
  then run $LIVEKITNAME\boot\bootinst.bat on Windows, or $LIVEKITNAME/boot/bootinst.sh
  on Linux.
* When installed on media with fat32 and ntfs file systems, changes in
  persistent changes mode will be saved in the $LIVEKITNAME\changes folder,
  dat files expands dynamically, file size can be changed
  with the perchsize parameter in the boot options, for example
  perchsize=4000 will set the maximum file size to 4 GB.
* When installed on media with ext2-ext4, xfs, btrfs file systems, changes in
  the persistent changes mode will be saved in the $LIVEKITNAME\changes folder with
  no size limit.
###############################################################################
EOF

    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
        # miniosbuild.conf generation is in linux-live/scripts/01-kernel/build
        if [ -f $MODULE_UPPER_DIR/miniosbuild.conf ]; then
            read_config $MODULE_UPPER_DIR/miniosbuild.conf KERNEL
        fi
        copy_build_scripts $MODULE_MERGED_DIR
        chmod +x $MODULE_MERGED_DIR/linux-live/initrfs
        chroot $MODULE_MERGED_DIR /linux-live/initrfs
        # copy boot files
        kernel_variables
        cp $MODULE_MERGED_DIR/boot/vmlinuz-* $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME
        cp $MODULE_MERGED_DIR/boot/initrfs.img $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME
        sed -i "s,/boot/vmlinuz,/boot/$VMLINUZNAME,g;s,/boot/initrfs.img,/boot/$INITRFSNAME,g" $WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
        if [ $BOOT_TYPE = "hybrid" ]; then
            sed -i "s,/boot/vmlinuz,/boot/$VMLINUZNAME,g;s,/boot/initrfs.img,/boot/$INITRFSNAME,g" $WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
        fi
        if [ -d $MODULE_MERGED_DIR/linux-live ]; then
            rm -rf $MODULE_MERGED_DIR/linux-live
        fi
    fi
}
# =================================================================
#
#
# =================================================================
function build_iso() {
    current_process

    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    check_install_dir

    if [ "$UNATTENDED" = "true" ]; then
        INSTALL_DIR="$WORK_DIR/basesystem"
    fi
    if [ "$INSTALL_DIR" = "" ]; then
        LAST_INSTALL_DIR=$(cat "$SCRIPT_DIR/.install_dir")
        INSTALL_DIR=$LAST_INSTALL_DIR
    fi

    cd $WORK_DIR/image
    if [ ! -d $ISO_DIR ]; then
        mkdir -p $ISO_DIR
    fi

    mkdir -p $ISO_DIR

    DATE=$(date +%Y%m%d_%H%M)

    DIR=$WORK_DIR/image

    if [ $DESKTOP_ENVIRONMENT = "cloud" ] || [ $DESKTOP_ENVIRONMENT = "netdiag" ] || [ $DESKTOP_ENVIRONMENT = "pve" ] || [ $DESKTOP_ENVIRONMENT = "xfce-ultra" ] || [ $DESKTOP_ENVIRONMENT = "xfce-puzzle" ] || [ $DESKTOP_ENVIRONMENT = "xfce-puzzle-base" ]; then
        IMAGE=$LIVEKITNAME-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$LANGUAGE_CODE$INITRD_TYPE_SUFFIX
    else
        IMAGE=$LIVEKITNAME-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$LANGUAGE_CODE$INITRD_TYPE_SUFFIX
    fi
    if [ $KERNEL_AUFS = "true" ]; then
        IMAGE=$IMAGE-aufs
    fi
    if [ $KERNEL_TYPE = "default" ]; then
        IMAGE=$IMAGE-$ISO_ARCH
    else
        IMAGE=$IMAGE-$KERNEL_TYPE-$ISO_ARCH
    fi
    if [ $BUILD_FROM_SNAPSHOT = "true" ]; then
        IMAGE=$IMAGE-$SNAPSHOT_DATE
    fi
    ISO=$ISO_DIR/$IMAGE-$COMP_TYPE-$DATE.iso

    B="-b $LIVEKITNAME/boot/isolinux.bin -c $LIVEKITNAME/boot/isolinux.boot"

    if [ $BOOT_TYPE = "hybrid" ]; then
        C="-no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot"
    else
        C="-no-emul-boot -boot-load-size 4 -boot-info-table"
    fi

    if [ -x "$(which xorriso)" ] && [ $BOOT_TYPE = "hybrid" ]; then
        M="xorriso -as mkisofs -isohybrid-mbr $DIR/$LIVEKITNAME/boot/isohdpfx.bin"
        D=" -isohybrid-gpt-basdat -e"
    elif [ -x "$(which genisoimage)" ]; then
        M=genisoimage
        if [ $BOOT_TYPE = "hybrid" ]; then
            D="-efi-boot"
        else
            D=""
        fi
    fi
    if [ $BOOT_TYPE = "hybrid" ]; then
        E="$LIVEKITNAME/boot/grub/efi.img -no-emul-boot"
    else
        E=""
    fi

    VER="$SYSTEMNAME"

    if [ $REMOVE_OLD_ISO = "true" ]; then
        set +e
        rm $ISO_DIR/$IMAGE-$COMP_TYPE-*.iso
        while [ -f $ISO_DIR/$LIVEKITNAME.iso ]; do
            rm $ISO_DIR/$LIVEKITNAME.iso
            sleep 1
        done
        set -e
    fi

    if [ $BOOT_TYPE = "hybrid" ]; then
        if
            ! $M -hide-rr-moved -f -r -J -l -V "$VER" -A "$VER" \
                $B $C $D $E -o $ISO $DIR
        then
            exit 1
        fi
        # testing iso boot transition to grub.
        : 'xorriso -as mkisofs -r \
            -V "$VER" \
            -o "$ISO-2" \
            --grub2-mbr "$LIVEKITNAME/boot/grub/boot_hybrid.img" \
            -partition_offset 16 \
            --mbr-force-bootable \
            -append_partition 2 28732ac11ff8d211ba4b00a0c93ec93b "$LIVEKITNAME/boot/grub/efi.img" \
            -appended_part_as_gpt \
            -iso_mbr_part_type a2a0d0ebe5b9334487c068b6b72699c7 \
            -c "$LIVEKITNAME/boot/grub/boot.catalog" \
            -b "$LIVEKITNAME/boot/grub/i386-pc/eltorito.img" \
            -no-emul-boot -boot-load-size 4 -boot-info-table --grub2-boot-info \
            -eltorito-alt-boot \
            -e "--interval:appended_partition_2:::" \
            -no-emul-boot \
            $DIR'
    else
        if
            ! $M -f -r -J -l -V "$VER" -A "$VER" \
                $B $C $D $E -o $ISO $DIR
        then
            exit 1
        fi
    fi

    echo ">>> $ISO created"

    if [ $BUILD_TEST_ISO = "true" ]; then
        if [ -L $ISO_DIR/$LIVEKITNAME.iso ]; then
            rm $ISO_DIR/$LIVEKITNAME.iso
        fi
        while [ -f $ISO_DIR/$LIVEKITNAME.iso ]; do
            rm $ISO_DIR/$LIVEKITNAME.iso
            sleep 1
        done
        if ln $ISO $ISO_DIR/$LIVEKITNAME.iso; then
            echo ">>> $ISO_DIR/$LIVEKITNAME.iso created"
        fi
    fi

    #exit 0
}

function remove_sources() {
    current_function
    if [ $REMOVE_SOURCES = "true" ]; then
        cleanup
    fi
    exit 0
}

# =================================================================
# =================================================================
# ====================== INSTALL FUNCTIONS ========================
# =================================================================
# =================================================================

# =================================================================
#
#
# =================================================================
function setup_host() {
    if [ $SKIP_SETUP_HOST != "true" ]; then
        current_process

        if [ $CONTAINER_TYPE != "2" ]; then
            hostreq_pkg_list
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function chroot_setup_host() {
    current_process

    echo $LIVEKITNAME >/etc/hostname

    install_prerequesited_packages

    #configure machine id
    dbus-uuidgen >/etc/machine-id
    ln -fs /etc/machine-id /var/lib/dbus/machine-id

    # don't understand why, but multiple sources indicate this
    dpkg-divert --local --rename --add /sbin/initctl
    ln -s /bin/true /sbin/initctl
}

# =================================================================
#
#
# =================================================================
function chroot_cleanup() {
    current_function

    set +eu

    rm -f $1/$LIVEKITNAME.conf 2>/dev/null
    rm -f $1/$PACKAGE_VARIANT.list 2>/dev/null
    rm -f $1/$PACKAGE_VARIANT-l10n.list 2>/dev/null
    rm -f $1/build 2>/dev/null
    rm -f $1/cleanup 2>/dev/null
    rm -f $1/functions 2>/dev/null
    rm -f $1/minioslib 2>/dev/null
    rm -f $1/install 2>/dev/null
    rm -f $1/package.list 2>/dev/null
    rm -f $1/postinstall 2>/dev/null
    rm -f $1/preinstall 2>/dev/null
    rm -rf $1/patches 2>/dev/null
    rm -rf $1/rootcopy 2>/dev/null
    rm -rf $1/rootcopy-install 2>/dev/null
    rm -f $1/etc/apt/sources.list~ 2>/dev/null
    rm -f $1/etc/fstab 2>/dev/null
    rm -f $1/etc/mtab 2>/dev/null
    rm -f $1/etc/ssh/ssh_host* 2>/dev/null
    rm -f $1/etc/systemd/system/multi-user.target.wants/dnsmasq.service 2>/dev/null
    rm -f $1/root/.bash_history 2>/dev/null
    rm -f $1/root/.wget-hsts 2>/dev/null
    rm -f $1/root/.wget-hsts 2>/dev/null
    rm -f $1/usr/share/applications/compton.desktop 2>/dev/null
    rm -f $1/usr/share/applications/debian-uxterm.desktop 2>/dev/null
    rm -f $1/usr/share/applications/debian-xterm.desktop 2>/dev/null
    rm -f $1/usr/share/applications/htop.desktop 2>/dev/null
    rm -f $1/usr/share/applications/mc.desktop 2>/dev/null
    rm -f $1/usr/share/applications/mcedit.desktop 2>/dev/null
    rm -f $1/usr/share/applications/pcmanfm-desktop-pref.desktop 2>/dev/null
    rm -f $1/usr/share/applications/python2.*.desktop 2>/dev/null
    rm -f $1/usr/share/applications/python3.*.desktop 2>/dev/null
    rm -f $1/usr/share/applications/vim.desktop 2>/dev/null
    rm -f $1/usr/share/images/fluxbox/debian-squared.jpg 2>/dev/null
    rm -f $1/var/backups/* 2>/dev/null
    rm -f $1/var/cache/apt/*.bin 2>/dev/null
    #rm -f $1/var/cache/apt/archives/*.deb 2>/dev/null
    rm -f $1/var/cache/debconf/* 2>/dev/null
    rm -f $1/var/cache/debconf/*-old 2>/dev/null
    rm -f $1/var/cache/fontconfig/* 2>/dev/null
    rm -f $1/var/cache/ldconfig/* 2>/dev/null
    rm -f $1/var/lib/apt/extended_states 2>/dev/null
    rm -f $1/var/lib/apt/lists/deb.* 2>/dev/null
    rm -f $1/var/lib/dhcp/dhclient.leases 2>/dev/null
    rm -f $1/var/lib/dpkg/*-old 2>/dev/null
    rm -f $1/var/lib/systemd/random-seed 2>/dev/null
    #rm -f $1/var/log/* 2>/dev/null
    find $1/var/log/ -type f ! -name "xrdp.log" -exec rm -f {} \; 2>/dev/null
    rm -f $1/var/log/*/* 2>/dev/null
    rm -f $1/var/log/*/*/* 2>/dev/null
    rm -Rf $1/etc/systemd/system/timers.target.wants 2>/dev/null
    rm -Rf $1/root/.cache 2>/dev/null
    rm -Rf $1/root/.local/share/mc 2>/dev/null
    rm -Rf $1/usr/share/doc/* 2>/dev/null
    rm -Rf $1/usr/share/gnome/help 2>/dev/null
    rm -Rf $1/usr/share/icons/elementaryXubuntu-dark 2>/dev/null
    rm -Rf $1/usr/share/icons/gnome/256x256 2>/dev/null
    rm -Rf $1/usr/share/info/* 2>/dev/null
    rm -Rf $1/usr/share/man/?? 2>/dev/null
    rm -Rf $1/usr/share/man/*_* 2>/dev/null
    if [ $REMOVE_LARGE_ICONS = "true" ]; then
        find $1/usr/share/icons/ -name 256x256 -o -name 512x512 -o -name 1024x1024 2>/dev/null | xargs rm -rf
    fi

    if [ $MULTILINGUAL = "true" ]; then
        # List of locales to keep
        LOCALES_TO_KEEP=("${LOCALES[@]}")
    else
        LOCALES_TO_KEEP=("$LOCALE")
    fi
    if [ $LOCALE = "en_US" ] && [ $MULTILINGUAL != "true" ]; then
        rm -rf $1/usr/share/fluxbox/nls/??* 2>/dev/null
        rm -rf $1/usr/share/locale/?? 2>/dev/null
        rm -rf $1/usr/share/locale/??_* 2>/dev/null
        rm -rf $1/usr/share/locale/??@* 2>/dev/null
        rm -rf $1/usr/share/locale/??? 2>/dev/null
        rm -rf $1/usr/share/i18n/locales/*_* 2>/dev/null
    else
        # Paths and patterns where excess locales will be deleted
        PATHS_AND_PATTERNS_TO_CLEAN=(
            "$1/usr/share/fluxbox/nls/??*"
            "$1/usr/share/locale/??"
            "$1/usr/share/locale/??_*"
            "$1/usr/share/locale/??@*"
            "$1/usr/share/locale/???"
            "$1/usr/share/i18n/locales/*_*"
        )

        # Iterate over all paths and patterns
        for PATH_AND_PATTERN in "${PATHS_AND_PATTERNS_TO_CLEAN[@]}"; do
            echo "Checking files in $PATH_AND_PATTERN..."

            # Iterate over all files and directories matching the current pattern
            for FILE in $PATH_AND_PATTERN; do
                # Get the name of the file or directory without the full path
                FILENAME=$(basename "$FILE")

                # Check if this file or directory should be kept
                KEEP=false
                for ITEM in "${LOCALES_TO_KEEP[@]}"; do
                    ITEM_CODE=$(echo $ITEM | cut -d_ -f1)
                    if [[ "$FILENAME" == "$ITEM"* ]] || [[ "$FILENAME" == "$ITEM_CODE" ]]; then
                        KEEP=true
                        break
                    fi
                done

                # If the file or directory should not be kept, delete it
                if ! $KEEP; then
                    echo "Deleting $FILE..."
                    rm -rf "$FILE"
                else
                    echo "Keeping $FILE..."
                fi
            done
        done

        echo "Locale cleanup completed."
    fi

    if [ -z $1 ]; then
        uncompress_files $1/etc/alternatives
        uncompress_files $1/usr/share/man

        remove_broken_links $1/etc/alternatives
        remove_broken_links $1/usr/share/man
    fi

    set -eu
}

# =================================================================
#
#
# =================================================================
function hostreq_pkg_list() {
    echo -e "${YELLOW}=====> installing required software for host system ...${ENDCOLOR}"

    pkgs_to_install=""
    if [ -f $SCRIPT_DIR/linux-live/package_lists/required_for_host.list ]; then
        pkgs_to_install=$(grep -vE "^\s*#" $SCRIPT_DIR/linux-live/package_lists/required_for_host.list | tr "\n" " ")
    else
        pkgs_to_install="sudo debootstrap genisoimage"
    fi
    if [ $DISTRIBUTION_ARCH = "arm64" ]; then
        pkgs_to_install="$pkgs_to_install grub-efi-arm64-bin"
    else
        pkgs_to_install="$pkgs_to_install grub-efi-amd64-bin grub-pc-bin"
    fi

    pkgs_to_install_filtered=""
    for pkg in $pkgs_to_install; do
        if ! dpkg-query -W -f='${Status}' $pkg 2>/dev/null | grep -q "ok installed"; then
            pkgs_to_install_filtered="$pkgs_to_install_filtered $pkg"
        fi
    done

    if [ -n "$pkgs_to_install_filtered" ]; then
        pkg update
        pkg install $pkgs_to_install_filtered
    fi
}

# =================================================================
#
#
# =================================================================
function install_prerequesited_packages() {
    echo -e "${YELLOW}=====> installing prerequested software for chroot system ...${ENDCOLOR}"

    if [ ! -f /etc/apt/apt.conf.d/000MiniOS ]; then
        cat <<'EOF' >/etc/apt/apt.conf.d/000MiniOS
APT::Install-Recommends "0";
APT::Install-Suggests "0";
Acquire::Languages { "none"; }
EOF
    fi

    if [ -f $SCRIPT_DIR/package_lists/prerequisites.list ]; then
        pkg update
        echo -e "${YELLOW}=====> upgrading chroot system ...${ENDCOLOR}"
        pkg upgrade
        echo -e "${YELLOW}=====> installing packages ...${ENDCOLOR}"
        install_packages --package-list=$SCRIPT_DIR/package_lists/prerequisites.list
    fi

}

# =================================================================
#
#
# =================================================================
function install_core_packages() {
    echo -e "${YELLOW}=====> installing main packages for chroot system ...${ENDCOLOR}"

    get_vars

    if [ -f /linux-live/basesystem/00-core/preinstall ]; then
        chmod +x /linux-live/basesystem/00-core/preinstall
        /linux-live/basesystem/00-core/preinstall
    fi
    if [ -f /linux-live/basesystem/00-core/install ]; then
        chmod +x /linux-live/basesystem/00-core/install
        /linux-live/basesystem/00-core/install
    fi
    if [ -f /linux-live/basesystem/00-core/postinstall ]; then
        chmod +x /linux-live/basesystem/00-core/postinstall
        /linux-live/basesystem/00-core/postinstall
    fi

    chroot_cleanup
}

# =================================================================
# unused
# =================================================================
function build_dkms() {
    if [ $KERNEL_TYPE != "none" ]; then
        echo -e "${YELLOW}=====> building dkms packages for chroot system ...${ENDCOLOR}"

        local LOWER_DIR MODULE_UPPER_DIR MODULE_WORK_DIR MODULE_MERGED_DIR KERNEL BUILD_DKMS

        LOWER_DIR="$WORK_DIR/basesystem"
        MODULE_UPPER_DIR="$WORK_DIR/modules/01-dkms-upper"
        MODULE_WORK_DIR="$WORK_DIR/modules/01-dkms-work"
        MODULE_MERGED_DIR="$WORK_DIR/modules/01-dkms-merged"
        BUILD_DKMS="true"

        module_check_install_dir

        module_chroot_mount_fs
        # run install script
        if [ -f $SCRIPT_DIR/linux-live/basesystem/01-dkms/install ]; then
            cp $SCRIPT_DIR/linux-live/basesystem/01-dkms/install $MODULE_MERGED_DIR/install
            chmod +x $MODULE_MERGED_DIR/install
            chroot_run $MODULE_MERGED_DIR /install
        fi

        module_chroot_umount_fs

        module_check_mounted

        if [ -f $MODULE_UPPER_DIR/miniosbuild.conf ]; then
            read_config $MODULE_UPPER_DIR/miniosbuild.conf KERNEL

            if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build ]; then
                rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build
            fi
            if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source ]; then
                rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source
            fi
            set +e
            if [ -d $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL ]; then
                (cd $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL && cp --parents -afr * /$LOWER_DIR/usr/lib/modules/$KERNEL/)
            fi
            if [ -d $MODULE_UPPER_DIR/lib/modules/$KERNEL ]; then
                (cd $MODULE_UPPER_DIR/lib/modules/$KERNEL && cp --parents -afr * /$LOWER_DIR/lib/modules/$KERNEL/)
            fi
            set -e
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function chroot_pkg_install() {
    current_process

    install_core_packages

    # remove unused
    pkg autoremove

    # clean up apt cache
    #pkg clean
}

# =================================================================
# The chroot_finish_up function performs cleanup tasks within a chroot environment.
# It removes diversions, temporary files, log files, and cache files.
# =================================================================
function chroot_finish_up() {
    current_process

    # truncate machine id (why??)
    truncate -s 0 /etc/machine-id

    # remove diversion (why??)
    rm /sbin/initctl 2>/dev/null
    dpkg-divert --rename --remove /sbin/initctl

    # remove ssh config
    #rm -f /etc/ssh/ssh_host*

    # clean up useless stuff
    rm -rf /tmp/* ~/.bash_history rm /sbin/initctl 2>/dev/null
    rm -rf ~/.cache rm /sbin/initctl 2>/dev/null
    find /var/log/ -type f | xargs rm -f rm /sbin/initctl 2>/dev/null
    rm -f /etc/ssh/ssh_host* rm /sbin/initctl 2>/dev/null
    rm -f /var/backups/* 2>/dev/null
    rm -f /var/cache/ldconfig/* 2>/dev/null
    #rm -f /var/cache/debconf/* 2>/dev/null
    rm -f /var/cache/fontconfig/* 2>/dev/null
    #rm -f /var/cache/apt/archives/*.deb 2>/dev/null
    rm -f /var/cache/apt/*.bin 2>/dev/null
    rm -f /var/cache/debconf/*-old 2>/dev/null
    rm -f /var/lib/apt/extended_states 2>/dev/null
    rm -f /var/lib/apt/lists/*Packages 2>/dev/null
    rm -f /var/lib/apt/lists/*Translation* 2>/dev/null
    rm -f /var/lib/apt/lists/*InRelease 2>/dev/null
    rm -f /var/lib/apt/lists/deb.* 2>/dev/null
    rm -f /var/lib/dpkg/*-old 2>/dev/null
}

# =================================================================
# Function is used to install packages on a system using the
# packages list.
# =================================================================
# Usage:
#   install_packages [options]
#
# Options:
#   -l, --package-list=FILE
#     Specify the path to the package list file. If not specified, the default
#     value of $SCRIPT_DIR/$PACKAGE_VARIANT.list will be used.
#
#   -s, --sed-script=SCRIPT
#     Specify a sed script to modify the package list. This option is provided
#     for backward compatibility and is not recommended for new code. Instead,
#     use the --delete-packages and --replace-packages options to remove or
#     replace packages in the package list.
#
#   -d, --delete-packages=PACKAGES
#     Specify packages to delete from the package list, separated by spaces.
#
#   -r, --replace-packages=PACKAGES
#     Specify packages to replace in the package list, in the form
#     old_package=new_package, separated by spaces.
#
#   -a, --add-packages=PACKAGES
#     Specify additional packages to install, separated by spaces.
#
#   -t, --target-release=RELEASE
#     Specify the target release for package installation. If provided, this
#     value will be passed to the `pkg install` command using the `-t` option.
#
function install_packages() {
    local SED_SCRIPT=""
    local ADD_PACKAGES=()
    local DELETE_PACKAGES=""
    local REPLACE_PACKAGES=""
    local PACKAGE_LIST=""
    local TARGET_RELEASE=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
        -s | --sed-script=*)
            if [[ "$1" == --* ]]; then
                SED_SCRIPT="${1#*=}"
            else
                SED_SCRIPT="$2"
                shift
            fi
            shift
            ;;
        -a | --add-packages=*)
            if [[ "$1" == --* ]]; then
                ADD_PACKAGES+=(${1#*=})
            else
                ADD_PACKAGES+=($2)
                shift
            fi
            shift
            ;;
        -d | --delete-packages=*)
            if [[ "$1" == --* ]]; then
                DELETE_PACKAGES="${1#*=}"
            else
                DELETE_PACKAGES="$2"
                shift
            fi
            shift
            ;;
        -r | --replace-packages=*)
            if [[ "$1" == --* ]]; then
                REPLACE_PACKAGES="${1#*=}"
            else
                REPLACE_PACKAGES="$2"
                shift
            fi
            shift
            ;;
        -l | --package-list=*)
            if [[ "$1" == --* ]]; then
                PACKAGE_LIST="${1#*=}"
            else
                PACKAGE_LIST="$2"
                shift
            fi
            shift
            ;;
        -t | --target-release=*)
            if [[ "$1" == --* ]]; then
                TARGET_RELEASE="${1#*=}"
            else
                TARGET_RELEASE="$2"
                shift
            fi
            shift
            ;;
        *)
            echo "Invalid option: $1" >&2
            exit 1
            ;;
        esac
    done

    if [[ -z "$PACKAGE_LIST" ]]; then
        if [ -f "$SCRIPT_DIR/$PACKAGE_VARIANT.list" ]; then
            PACKAGE_LIST="$SCRIPT_DIR/$PACKAGE_VARIANT.list"
        elif [ -f "$SCRIPT_DIR/package.list" ]; then
            PACKAGE_LIST="$SCRIPT_DIR/package.list"
        else
            echo "There are no lists of packages here."
            exit 1
        fi
    fi

    # Build sed script for removing and replacing packages.
    for PKG in $DELETE_PACKAGES; do
        SED_SCRIPT+="/$PKG/d;"
    done

    for PKG in $REPLACE_PACKAGES; do
        OLD_PKG="${PKG%%=*}"
        NEW_PKG="${PKG#*=}"
        SED_SCRIPT+="s#$OLD_PKG#$NEW_PKG#g;"
    done

    pkg update

    if [[ -z "$SED_SCRIPT" ]]; then
        pkg install ${TARGET_RELEASE:+-t $TARGET_RELEASE} \
            $(grep -vE "^\s*#" $PACKAGE_LIST | tr "\n" " ") ${ADD_PACKAGES[@]}
    else
        pkg install ${TARGET_RELEASE:+-t $TARGET_RELEASE} \
            $(grep -vE "^\s*#" $PACKAGE_LIST | sed "$SED_SCRIPT" | tr "\n" " ") ${ADD_PACKAGES[@]}
    fi
}

# =================================================================
# =================================================================
# ======================= MODULE FUNCTIONS ========================
# =================================================================
# =================================================================

function module_add_unofficial_repository() {
    current_function
    if [ $DISTRIBUTION = "buster" ] || [ $DISTRIBUTION = "bullseye" ]; then
        if [ $USE_UNOFFICIAL_REPOSITORY = "true" ]; then
            if [ ! -d $MODULE_UPPER_DIR/etc/apt ]; then
                mkdir -p $MODULE_UPPER_DIR/etc/apt
            fi
            cat <<EOF >$MODULE_UPPER_DIR/etc/apt/sources.list
deb $UNOFFICIAL_REPOSITORY_ADDRESS $DISTRIBUTION main contrib non-free
EOF
        fi
    fi
}

function module_remove_unofficial_repository() {
    current_function
    if [ -f $MODULE_UPPER_DIR/etc/apt/sources.list ]; then
        rm $MODULE_UPPER_DIR/etc/apt/sources.list
    fi
}

# =================================================================
#
#
# =================================================================
function module_check_mounted() {
    current_function
    if grep -qs "$MODULE_MERGED_DIR" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/dev" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/run" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/proc" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/sys" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/dev/pts" /proc/mounts || grep -qs "$MODULE_MERGED_DIR/tmp" /proc/mounts; then
        echo -e "${BOLD}${LIGHTYELLOW}Сhroot contains mounted filesystems.${ENDCOLOR}"
        if [ "$UNATTENDED" = "true" ]; then
            module_chroot_umount_fs
        else
            read -r -p "$(echo -e ""Do you want to ${GREEN}unmount them${ENDCOLOR}? [${BOLD}${GREEN}Y${ENDCOLOR}/n])" response
            response=${response,,}
            if [[ "$response" =~ ^(no|n)$ ]]; then
                exit 1
            else
                module_chroot_umount_fs
            fi
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_check_install_dir() {
    current_function
    if [ "$UNATTENDED" = "true" ]; then
        #echo -e "${RED}!!!Unattended installation!!!${ENDCOLOR}"
        echo -e "The working directory is ${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR}."
        if [ "$(ls -A $MODULE_UPPER_DIR 2>/dev/null)" != "" ]; then
            module_cleanup
            module_check_mounted
        fi
    else
        if [ "$(ls -A $MODULE_UPPER_DIR 2>/dev/null)" != "" ]; then
            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} is not empty."
            module_cleanup
            module_check_mounted
            echo -e "The working directory is ${MAGENTA}$MODULE_MERGED_DIR${ENDCOLOR}."
        else
            module_check_mounted
            echo -e "The working directory is ${MAGENTA}$MODULE_MERGED_DIR${ENDCOLOR}."
        fi
    fi
}

function filter_modules() {
    current_function
    if [ $PACKAGE_VARIANT = "puzzle" ]; then
        FILTER_MODULES="true"
        if ! [[ $MODULE =~ ^0[0-9]-* ]]; then
            FILTER_LEVEL="3"
        elif [[ $MODULE == "00-"* ]] || [[ $MODULE == "01-"* ]]; then
            FILTER_LEVEL="0"
        else
            FILTER_LEVEL=$((${MODULE:1:1} - 1))
        fi
    else
        if [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
            read_config $SCRIPT_DIR/linux-live/container_buildconfig FILTER_MODULES FILTER_LEVEL
        elif [ $SCRIPT_DIR = "/usr/bin" ]; then
            read_config /etc/minios/buildconfig FILTER_MODULES FILTER_LEVEL
        else
            read_config $SCRIPT_DIR/linux-live/buildconfig FILTER_MODULES FILTER_LEVEL
            : 'if [ $FILTER_MODULES = "true" ]; then
                FILTER_MODULES="true"
                if [[ $MODULE == "00-"* ]] || [[ $MODULE == "01-"* ]]; then
                    FILTER_LEVEL="0"
                else
                    FILTER_LEVEL=$((${MODULE:1:1} - 1))
                fi
            fi'
        fi
    fi
    echo -e "=====  ${YELLOW}MODULE=$MODULE${ENDCOLOR}"
    echo -e "=====  ${YELLOW}FILTER_MODULES=$FILTER_MODULES${ENDCOLOR}"
    echo -e "=====  ${YELLOW}FILTER_LEVEL=$FILTER_LEVEL${ENDCOLOR}"
    if [ $FILTER_MODULES = "true" ]; then
        MODULES_LIST=$(ls -1dr $1[0]* | egrep "0[0-$FILTER_LEVEL]" | tr '\n' ':')
    else
        MODULES_LIST=$(ls -1dr $1[0-9]* | tr '\n' ':')
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_mount_fs() {
    current_function

    local MODULES BUNDLE FILTER

    module_check_mounted

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        mkdir -p $MODULES_DIR
    fi

    set +u

    if [ -z $BUILD_DKMS ] || [ $BUILD_DKMS != "true" ]; then
        if [ $UNION_BUILD_TYPE = "overlayfs" ]; then
            MODULES_LIST=""
            if [ $SCRIPT_DIR != "/usr/bin" ]; then
                MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
                for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
                    BUNDLE=$(basename ${MODULES[$i]} .$BEXT)
                    mkdir -p $MODULES_DIR/bundles/$BUNDLE
                    mount ${MODULES[$i]} $MODULES_DIR/bundles/$BUNDLE
                done
                set +e
                filter_modules $MODULES_DIR/bundles/
                MODULES_LIST=${MODULES_LIST/%:/}
                set -e
            else
                MODULES=$BUNDLES/
                filter_modules $MODULES
                MODULES_LIST=${MODULES_LIST/%:/}
            fi
            mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
            mount -t overlay overlay -o lowerdir=$MODULES_LIST,upperdir=$MODULE_UPPER_DIR,workdir=$MODULE_WORK_DIR $MODULE_MERGED_DIR
        elif [ $UNION_BUILD_TYPE = "aufs" ]; then
            MODULES_LIST=""
            if [ $SCRIPT_DIR != "/usr/bin" ]; then
                MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
                for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
                    BUNDLE=$(basename ${MODULES[$i]} .$BEXT)
                    mkdir -p $MODULES_DIR/bundles/$BUNDLE
                    mount ${MODULES[$i]} $MODULES_DIR/bundles/$BUNDLE
                    MODULES_LIST=$MODULES_LIST":""$MODULES_DIR/bundles/$BUNDLE""=ro"
                done
                MODULES_LIST=${MODULES_LIST:1}
            else
                MODULES=$BUNDLES/
                filter_modules $MODULES
                MODULES_LIST=${MODULES_LIST/%:/}
            fi
            mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
            mount -t aufs -o br:$MODULE_UPPER_DIR=rw:$MODULES_LIST aufs $MODULE_MERGED_DIR
        fi
    else
        mkdir -p $MODULE_UPPER_DIR $MODULE_WORK_DIR $MODULE_MERGED_DIR
        if [ $UNION_BUILD_TYPE = "overlayfs" ]; then
            mount -t overlay overlay -o lowerdir=$LOWER_DIR,upperdir=$MODULE_UPPER_DIR,workdir=$MODULE_WORK_DIR $MODULE_MERGED_DIR
        elif [ $UNION_BUILD_TYPE = "aufs" ]; then
            mount -t aufs -o br:$MODULE_UPPER_DIR=rw:$LOWER_DIR aufs $MODULE_MERGED_DIR
        fi
    fi

    set -u

    if [ ! -d $MODULE_MERGED_DIR/dev ]; then
        mkdir -p $MODULE_MERGED_DIR/dev
    fi
    if [ ! -d $MODULE_MERGED_DIR/run ]; then
        mkdir -p $MODULE_MERGED_DIR/run
    fi
    if [ ! -d $MODULE_MERGED_DIR/proc ]; then
        mkdir -p $MODULE_MERGED_DIR/proc
    fi
    if [ ! -d $MODULE_MERGED_DIR/sys ]; then
        mkdir -p $MODULE_MERGED_DIR/sys
    fi
    if [ ! -d $MODULE_MERGED_DIR/tmp ]; then
        mkdir -p $MODULE_MERGED_DIR/tmp
    fi

    mount --bind /dev $MODULE_MERGED_DIR/dev

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        echo "nameserver 8.8.8.8" >$MODULE_MERGED_DIR/etc/resolv.conf
    else
        if [ -f /.dockerenv ] || [ "$container" = "podman" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
            if [ -L $MODULE_MERGED_DIR/etc/resolv.conf ] || [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                if [ -L $MODULE_MERGED_DIR/etc/resolv.conf ]; then
                    if [ $DISTRIBUTION_TYPE = "ubuntu" ]; then
                        rm $MODULE_MERGED_DIR/etc/resolv.conf
                    else
                        mv $MODULE_MERGED_DIR/etc/resolv.conf $MODULE_MERGED_DIR/etc/resolv.conf.bak
                    fi
                fi
                echo "nameserver 8.8.8.8" >>$MODULE_MERGED_DIR/etc/resolv.conf
            fi
        else
            mount --bind /run $MODULE_MERGED_DIR/run
        fi
    fi
    mount none -t proc $MODULE_MERGED_DIR/proc
    mount none -t sysfs $MODULE_MERGED_DIR/sys
    mount none -t devpts $MODULE_MERGED_DIR/dev/pts
    mount none -t tmpfs $MODULE_MERGED_DIR/tmp
    if [ ! -d $SCRIPT_DIR/aptcache/$DISTRIBUTION ]; then
        mkdir -p $SCRIPT_DIR/aptcache/$DISTRIBUTION
    fi
    if [ ! -d $MODULE_MERGED_DIR/var/cache/apt/archives ]; then
        mkdir -p $MODULE_MERGED_DIR/var/cache/apt/archives
    fi
    mount --bind $SCRIPT_DIR/aptcache/$DISTRIBUTION $MODULE_MERGED_DIR/var/cache/apt/archives
}

# =================================================================
#
#
# =================================================================
function module_chroot_umount_fs() {
    current_function

    local MODULES BUNDLE

    set +e
    umount $MODULE_MERGED_DIR/var/cache/apt/archives
    umount $MODULE_MERGED_DIR/proc
    umount $MODULE_MERGED_DIR/sys
    umount $MODULE_MERGED_DIR/dev/pts
    umount $MODULE_MERGED_DIR/tmp
    umount $MODULE_MERGED_DIR/dev
    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        rm -f $MODULE_UPPER_DIR/etc/resolv.conf

        umount $MODULE_MERGED_DIR

        umount $MODULES_DIR/bundles/*

        umount $MODULES_DIR
    else
        if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
            if [[ -e $MODULE_MERGED_DIR/etc/resolv.conf.bak && ! -L $MODULE_MERGED_DIR/etc/resolv.conf ]] || [ $DISTRIBUTION = "stretch" ]; then
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf
                mv $MODULE_MERGED_DIR/etc/resolv.conf.bak $MODULE_MERGED_DIR/etc/resolv.conf
            elif [ -e $MODULE_MERGED_DIR/etc/resolv.conf.bak ] && [ -L $MODULE_MERGED_DIR/etc/resolv.conf ]; then
                rm -f $MODULE_UPPER_DIR/etc/resolv.conf.bak
            fi
            : 'umount $MODULE_MERGED_DIR/run/resolvconf/resolv.conf
                rm -f $MODULE_UPPER_DIR/run/resolvconf/resolv.conf
                rmdir $MODULE_UPPER_DIR/run/resolvconf'
        else
            umount $MODULE_MERGED_DIR/run
        fi
        umount $MODULE_MERGED_DIR

        if [ -f /.dockerenv ] || [ "$container" = "podman" ]; then
            rm -f $MODULE_UPPER_DIR/etc/resolv.conf
            rm -f $MODULE_UPPER_DIR/etc/resolv.conf.bak
        fi
    fi

    set +u

    if [ -z $BUILD_DKMS ] || [ $BUILD_DKMS != "true" ]; then
        MODULES=($WORK_DIR/image/$LIVEKITNAME/*.$BEXT)
        for ((i = ${#MODULES[@]} - 1; i >= 0; i--)); do
            BUNDLE=$(basename ${MODULES[$i]} .$BEXT)
            umount $MODULES_DIR/bundles/$BUNDLE
        done
    fi

    set -eu

    module_check_mounted
}

# =================================================================
#
#
# =================================================================
function module_cleanup() {
    current_function
    if [ "$UNATTENDED" = "true" ]; then
        module_check_mounted
        rm -rf $MODULE_UPPER_DIR
        if [ -d "$MODULE_UPPER_DIR" ]; then
            module_cleanup
        fi
    else
        read -r -p "$(echo -e ""Do you want to ${BOLD}${RED}completely remove content${ENDCOLOR} of ${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR}? [y/${BOLD}${GREEN}N${ENDCOLOR}])" response
        response=${response,,}
        if [[ "$response" =~ ^(yes|y)$ ]]; then
            module_check_mounted
            rm -rf $MODULE_UPPER_DIR
            if [ -d "$MODULE_UPPER_DIR" ]; then
                module_cleanup
            fi
        else
            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} should be empty to continue."
            exit 1
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_finish_up() {
    current_function

    # truncate machine id (why??)
    chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
truncate -s 0 /etc/machine-id 2>/dev/null
EOF

    # remove diversion (why??)
    chroot $MODULE_MERGED_DIR /bin/bash -x <<EOF
    rm /sbin/initctl 2>/dev/null
    dpkg-divert --rename --remove /sbin/initctl 2>/dev/null
EOF

    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        if [ -d $MODULE_UPPER_DIR/home/$USER_NAME ]; then
            chown 1000:1000 $MODULE_UPPER_DIR/home/$USER_NAME
            chown -R 1000:1000 $MODULE_UPPER_DIR/home/$USER_NAME
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_chroot_cleanup() {
    current_function
    set +e
    # clean up useless stuff
    rm -rf $MODULE_UPPER_DIR/boot $MODULE_UPPER_DIR/dev $MODULE_UPPER_DIR/proc $MODULE_UPPER_DIR/sys $MODULE_UPPER_DIR/rmp $MODULE_UPPER_DIR/run
    rm -f $MODULE_UPPER_DIR/root/.bash_history
    rm -rf $MODULE_UPPER_DIR/.cache
    find $MODULE_UPPER_DIR/var/log/ -type f | xargs rm -f
    rm -f $MODULE_UPPER_DIR/etc/ssh/ssh_host*
    rm -f $MODULE_UPPER_DIR/var/backups/*
    rm -f $MODULE_UPPER_DIR/var/cache/ldconfig/*
    #rm -f $MODULE_UPPER_DIR/var/cache/debconf/*
    rm -f $MODULE_UPPER_DIR/var/cache/fontconfig/*
    #rm -f $MODULE_UPPER_DIR/var/cache/apt/archives/*.deb
    rm -f $MODULE_UPPER_DIR/var/cache/apt/*.bin
    rm -f $MODULE_UPPER_DIR/var/cache/debconf/*-old
    rm -f $MODULE_UPPER_DIR/var/lib/apt/extended_states
    rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Packages
    rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*Translation*
    rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/*InRelease
    rm -f $MODULE_UPPER_DIR/var/lib/apt/lists/deb.*
    rm -f $MODULE_UPPER_DIR/var/lib/dpkg/*-old
    rm -f $MODULE_UPPER_DIR/preinstall
    rm -f $MODULE_UPPER_DIR/install
    rm -f $MODULE_UPPER_DIR/build
    rm -f $MODULE_UPPER_DIR/cleanup
    rm -f $MODULE_UPPER_DIR/$PACKAGE_VARIANT.list
    rm -f $MODULE_UPPER_DIR/$PACKAGE_VARIANT-l10n.list
    rm -f $MODULE_UPPER_DIR/package.list
    rm -f $MODULE_UPPER_DIR/postinstall
    rm -rf $MODULE_UPPER_DIR/rootcopy
    rm -f $MODULE_UPPER_DIR/etc/machine-id
    rm -rf $MODULE_UPPER_DIR/var/cache
    if [ $REMOVE_DPKG_DB = "true" ]; then
        rm -rf $MODULE_UPPER_DIR/var/lib/dpkg
    fi
    if [ $REMOVE_LARGE_ICONS = "true" ]; then
        if [ -d $MODULE_UPPER_DIR/usr/share/icons ]; then
            find $MODULE_UPPER_DIR/usr/share/icons/ -name 256x256 -o -name 512x512 -o -name 1024x1024 | xargs rm -rf
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function module_build_cleanup() {
    current_function

    chroot_cleanup $MODULE_UPPER_DIR
}

# =================================================================
#
#
# =================================================================
function get_kernel_version() {
    current_function
    if [ $DISTRIBUTION_ARCH = "amd64" ]; then
        KERNEL_ARCH="amd64"
    elif [ $DISTRIBUTION_ARCH = "i386-pae" ]; then
        KERNEL_ARCH="686-pae"
    elif [ $DISTRIBUTION_ARCH = "i386" ]; then
        KERNEL_ARCH="686"
    elif [ $DISTRIBUTION_ARCH = "arm64" ]; then
        KERNEL_ARCH="arm64"
    fi
    if [ $KERNEL_AUFS = "true" ] && ! { [ $DISTRIBUTION = "stretch" ] || [ $DISTRIBUTION = "buster" ] || ([ $DISTRIBUTION = "bullseye" ] && [ $KERNEL_BPO != "true" ]); }; then
        if [ $KERNEL_BPO = "true" ]; then
            KERNEL_VERSION="6.0"
        else
            KERNEL_VERSION="5.10"
        fi
        if [ $KERNEL_TYPE = "default" ]; then
            KERNEL="$KERNEL_VERSION-$KERNEL_ARCH"
        else
            KERNEL="$KERNEL_VERSION-$KERNEL_TYPE-$KERNEL_ARCH"
        fi
    elif [ $KERNEL_TYPE = "none" ]; then
        KERNEL=""
    elif [ -f /usr/bin/dpkg-query ] 2>/dev/null; then
        KERNEL=$(dpkg-query -W -f='${binary:Package}\n' linux-image-* 2>/dev/null | head -n 1 | sed 's/linux-image-//')
    else
        KERNEL=$(uname -r)
    fi
    if echo $KERNEL | grep -q 'pve'; then
        KERNEL=${KERNEL::-6}
    fi
}

# =================================================================
#
#
# =================================================================
function export_kernel() {
    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
        if [ $EXPORT_KERNEL = "true" ]; then
            current_function
            kernel_variables
            if [ ! -d $KERNEL_DIR ]; then
                mkdir -p $KERNEL_DIR
            fi
            if [ $KERNEL_BUILD_DKMS = "true" ]; then
                KERNEL_MODULE_NAME=$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT
            else
                KERNEL_MODULE_NAME=$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT
            fi
            if [ -f $WORK_DIR/image/$LIVEKITNAME/$KERNEL_MODULE_NAME ]; then
                cp $WORK_DIR/image/$LIVEKITNAME/$KERNEL_MODULE_NAME $KERNEL_DIR
                if [ $NAMED_BOOT_FILES = "true" ]; then
                    cp $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME $KERNEL_DIR
                    cp $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME $KERNEL_DIR
                else
                    cp $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME $KERNEL_DIR/vmlinuz-$KERNEL_SUFFIX
                    cp $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME $KERNEL_DIR/initrfs-$KERNEL_SUFFIX-$INITRD_TYPE.img
                fi
                echo "Kernel files and initrd image have been exported to a folder $KERNEL_DIR"
            else
                echo "Kernel files could not be found."
            fi
        fi
        if [ $MOVE_KERNEL = "true" ]; then
            if [ ! -d $KERNEL_DIR ]; then
                mkdir -p $KERNEL_DIR
            fi
            if [ -f $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT ]; then
                mv $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT $KERNEL_DIR
                mv $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME $KERNEL_DIR
                mv $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME $KERNEL_DIR
                echo "Kernel files and initrd image have been moved to a folder $KERNEL_DIR"
            else
                echo "Kernel files could not be found."
            fi
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function kernel_variables() {
    KERNEL_SUFFIX=$KERNEL

    if [ $NAMED_BOOT_FILES = "true" ]; then
        VMLINUZNAME="vmlinuz-$KERNEL_SUFFIX"
        INITRFSNAME="initrfs-$KERNEL_SUFFIX-$INITRD_TYPE.img"
    else
        VMLINUZNAME="vmlinuz"
        INITRFSNAME="initrfs.img"
    fi
}

# =================================================================
#
#
# =================================================================
function create_initrfs() {
    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
        if [ -f $MODULE_UPPER_DIR/miniosbuild.conf ]; then
            read_config $MODULE_UPPER_DIR/miniosbuild.conf KERNEL
        fi
        copy_build_scripts $MODULE_MERGED_DIR
        chmod +x $MODULE_MERGED_DIR/linux-live/initrfs
        chroot $MODULE_MERGED_DIR /linux-live/initrfs
        # copy boot files
        kernel_variables
        if [ ls $MODULE_MERGED_DIR/boot/vmlinuz-**-**-* ] 2>/dev/null; then
            cp $MODULE_MERGED_DIR/boot/vmlinuz-**-**-* $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME
        elif [ ls $MODULE_MERGED_DIR/boot/vmlinuz-**.**.* ] 2>/dev/null; then
            cp $MODULE_MERGED_DIR/boot/vmlinuz-**.**.* $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME
        else
            cp $MODULE_MERGED_DIR/boot/vmlinuz-* $WORK_DIR/image/$LIVEKITNAME/boot/$VMLINUZNAME
        fi
        cp $MODULE_MERGED_DIR/boot/initrfs.img $WORK_DIR/image/$LIVEKITNAME/boot/$INITRFSNAME
        sed -i "s,/boot/vmlinuz,/boot/$VMLINUZNAME,g;s,/boot/initrfs.img,/boot/$INITRFSNAME,g" $WORK_DIR/image/$LIVEKITNAME/boot/syslinux.cfg
        sed -i "s,/boot/vmlinuz,/boot/$VMLINUZNAME,g;s,/boot/initrfs.img,/boot/$INITRFSNAME,g" $WORK_DIR/image/$LIVEKITNAME/boot/grub/grub.cfg
        if [ -d $MODULE_MERGED_DIR/linux-live ]; then
            rm -rf $MODULE_MERGED_DIR/linux-live
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function export_locales() {
    local FILE BASE_NAME NEW_NAME
    if [[ "$MODULE" == *"langpack"* ]]; then
        if [ "$MULTILINGUAL" = "true" ]; then
            current_function
            if [ ! -d $LOCALES_DIR ]; then
                mkdir -p $LOCALES_DIR
            fi
            for FILE in "$MODULE_UPPER_DIR"/*langpack*; do
                cp "$FILE" "$LOCALES_DIR/$(basename "$FILE")"
            done
        fi
    fi
}

# =================================================================
#
#
# =================================================================
function build_modules() {
    current_process
    if [ "${CMD[ii]}" != "build_dkms" ]; then

        local VMLINUZNAME INITRFSNAME KERNEL_SUFFIX PACKAGE VERSION BUNDLE

        if [ $CONTAINER_TYPE = "1" ]; then
            if [ ! -f /.minios-live ]; then
                setup_host
            fi
        fi

        if [ $SCRIPT_DIR = "/usr/bin" ]; then
            WORK_DIR=$CURRENT_DIR
            SOURCE_MODULES_DIR=$CURRENT_DIR/modules
            MODULES_DIR=/tmp/build

            if [ -d $SOURCE_MODULES_DIR ]; then
                cd $SOURCE_MODULES_DIR
            else
                help
            fi
        else
            SOURCE_MODULES_DIR=$SCRIPT_DIR/linux-live/modules/$DESKTOP_ENVIRONMENT
            MODULES_DIR=$WORK_DIR/modules

            cd $SOURCE_MODULES_DIR
        fi

        for MODULE in *; do
            if [ $SCRIPT_DIR != "/usr/bin" ] && (ls $WORK_DIR/image/$LIVEKITNAME/*.$BEXT 2>/dev/null | grep -q $MODULE 2>/dev/null); then
                echo -e "${MAGENTA}$MODULE${ENDCOLOR} module building is skipped, because it is already present in the image folder." #| fold -w 80 -s
            elif ([[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]) && [ $KERNEL_TYPE = "none" ]; then
                exit
            else
                MODULE_UPPER_DIR="$MODULES_DIR/$MODULE-upper"
                MODULE_WORK_DIR="$MODULES_DIR/$MODULE-work"
                MODULE_MERGED_DIR="$MODULES_DIR/$MODULE-merged"

                module_check_install_dir

                module_chroot_mount_fs

                module_add_unofficial_repository

                # run pre-install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/preinstall ]; then
                    cp $SOURCE_MODULES_DIR/$MODULE/preinstall $MODULE_MERGED_DIR/preinstall
                    chmod +x $MODULE_MERGED_DIR/preinstall
                    chroot_run $MODULE_MERGED_DIR /preinstall
                fi

                # copy files
                if [ -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install 2>/dev/null)" != "" ]; then
                        mkdir $MODULE_MERGED_DIR/rootcopy-install
                        (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-install/)
                    fi
                else
                    if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-install 2>/dev/null)" != "" ]; then
                        (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-install && cp --parents -afr * $MODULE_MERGED_DIR/)
                    fi
                fi

                # run install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/install ]; then
                    cp $SOURCE_MODULES_DIR/$MODULE/install $MODULE_MERGED_DIR/install
                    chmod +x $MODULE_MERGED_DIR/install
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/cleanup ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/cleanup $MODULE_MERGED_DIR/cleanup
                    fi
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/$PACKAGE_VARIANT.list ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/$PACKAGE_VARIANT.list $MODULE_MERGED_DIR/$PACKAGE_VARIANT.list
                    fi
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/$PACKAGE_VARIANT-l10n.list ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/$PACKAGE_VARIANT-l10n.list $MODULE_MERGED_DIR/$PACKAGE_VARIANT-l10n.list
                    fi
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/package.list ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/package.list $MODULE_MERGED_DIR/package.list
                    fi

                    chroot_run $MODULE_MERGED_DIR /install
                fi

                if [ -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    module_chroot_umount_fs

                    module_build_cleanup

                    module_remove_unofficial_repository

                    # run external actions
                    if [ "$(ls -A $MODULE_UPPER_DIR 2>/dev/null)" != "" ]; then
                        mkdir -p $WORK_DIR/modules/tmp
                        mkmod_corefs $MODULE_UPPER_DIR
                        time mksquashfs $MODULE_UPPER_DIR $WORK_DIR/modules/tmp/$MODULE-stock.$BEXT -comp lz4 -b 1024K -always-use-fragments -noappend || exit
                        mv $WORK_DIR/modules/tmp/$MODULE-stock.$BEXT $MODULE_UPPER_DIR/$MODULE-stock.$BEXT
                        cd $MODULE_UPPER_DIR
                        unsquashfs $MODULE-stock.$BEXT
                    else
                        echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} is empty. Nothing to do."
                    fi

                    module_chroot_mount_fs

                    module_add_unofficial_repository

                    # run build script
                    if [ -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                        cp $SOURCE_MODULES_DIR/$MODULE/build $MODULE_MERGED_DIR/build
                        chmod +x $MODULE_MERGED_DIR/build
                        if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/patches 2>/dev/null)" != "" ]; then
                            mkdir $MODULE_MERGED_DIR/patches
                            (cd $SOURCE_MODULES_DIR/$MODULE/patches && cp --parents -afr * $MODULE_MERGED_DIR/patches/)
                        fi

                        chroot_run $MODULE_MERGED_DIR /build

                        build_boot
                    fi
                fi

                if [ -f $SOURCE_MODULES_DIR/$MODULE/is_dkms_build ]; then
                    read_config $MODULE_UPPER_DIR/miniosbuild.conf KERNEL
                    if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build ]; then
                        rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/build
                    fi
                    if [ -L $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source ]; then
                        rm -f $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL/source
                    fi
                    if [ -L $MODULE_UPPER_DIR/lib/modules/$KERNEL/build ]; then
                        rm -f $MODULE_UPPER_DIR/lib/modules/$KERNEL/build
                    fi
                    if [ -L $MODULE_UPPER_DIR/lib/modules/$KERNEL/source ]; then
                        rm -f $MODULE_UPPER_DIR/lib/modules/$KERNEL/source
                    fi
                    set +e
                    if [ -d $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL ]; then
                        if [ ! -d $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL ]; then
                            mkdir -p $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL
                        fi
                        (cd $MODULE_UPPER_DIR/usr/lib/modules/$KERNEL && cp --parents -afr * $MODULE_UPPER_DIR/squashfs-root/usr/lib/modules/$KERNEL/)
                    fi
                    if [ -d $MODULE_UPPER_DIR/lib/modules/$KERNEL ]; then
                        if [ ! -d $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL ]; then
                            mkdir -p $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL
                        fi
                        (cd $MODULE_UPPER_DIR/lib/modules/$KERNEL && cp --parents -afr * $MODULE_UPPER_DIR/squashfs-root/lib/modules/$KERNEL/)
                    fi
                    set -e
                    if [ $MODULE = "01-kernel" ]; then
                        cd $MODULE_UPPER_DIR/squashfs-root
                        if ls initrd* 2>/dev/null; then
                            rm initrd*
                        fi
                        if ls vmlinuz* 2>/dev/null; then
                            rm vmlinuz*
                        fi
                        if [ $KERNEL_MODULES_ONLY = "true" ]; then
                            bash -c "
                            shopt -s extglob
                            rm -rf !(usr)
                            cd $MODULE_UPPER_DIR/squashfs-root/usr
                            rm -Rf !(lib)
                            cd $MODULE_UPPER_DIR/squashfs-root/usr/lib
                            rm -Rf !(modules)
                            cd $MODULE_UPPER_DIR/squashfs-root
                            shopt -u extglob
                            "
                        else
                            rm -Rf boot dev etc proc run sys tmp var/lib/apt
                        fi
                    fi

                    if [ $COMP_TYPE = "zstd" ]; then
                        chroot_run $MODULE_MERGED_DIR time mksquashfs /squashfs-root /$MODULE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                    elif [ $COMP_TYPE = "xz" ]; then
                        chroot_run $MODULE_MERGED_DIR time mksquashfs /squashfs-root /$MODULE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
                    else
                        chroot_run $MODULE_MERGED_DIR time mksquashfs /squashfs-root /$MODULE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                    fi

                    rm -f $MODULE_UPPER_DIR/miniosbuild.conf
                fi

                # copy files
                if [[ $MODULE == *"$LIVEKITNAME"* ]]; then
                    cp $SCRIPT_DIR/linux-live/minioslib $MODULE_MERGED_DIR/usr/lib/minioslib
                    cp $SCRIPT_DIR/linux-live/layoutcodes.csv $MODULE_MERGED_DIR/usr/share/minios/layoutcodes.csv
                    if [ ! -d $MODULE_MERGED_DIR/etc/minios ]; then
                        mkdir -p $MODULE_MERGED_DIR/etc/minios
                    fi
                    if [ -f $SCRIPT_DIR/linux-live/container_config ] && [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
                        cp $SCRIPT_DIR/linux-live/container_config $MODULE_MERGED_DIR/etc/minios/config
                        cp $SCRIPT_DIR/linux-live/container_buildconfig $MODULE_MERGED_DIR/etc/minios/buildconfig
                    else
                        cp $SCRIPT_DIR/linux-live/buildconfig $MODULE_MERGED_DIR/etc/minios/buildconfig
                        cp $SCRIPT_DIR/linux-live/config $MODULE_MERGED_DIR/etc/minios/config
                    fi
                    cp $SCRIPT_DIR/linux-live/kernelconfig $MODULE_MERGED_DIR/etc/minios/kernelconfig
                fi
                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall 2>/dev/null)" != "" ]; then
                        (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/)
                    fi
                else
                    if [ "$(ls -A $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall 2>/dev/null)" != "" ]; then
                        mkdir $MODULE_MERGED_DIR/rootcopy-postinstall
                        (cd $SOURCE_MODULES_DIR/$MODULE/rootcopy-postinstall && cp --parents -afr * $MODULE_MERGED_DIR/rootcopy-postinstall/)
                    fi
                fi

                # run post-install script
                if [ -f $SOURCE_MODULES_DIR/$MODULE/postinstall ]; then
                    cp $SOURCE_MODULES_DIR/$MODULE/postinstall $MODULE_MERGED_DIR/postinstall
                    chmod +x $MODULE_MERGED_DIR/postinstall
                    chroot_run $MODULE_MERGED_DIR /postinstall
                fi

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    set +e
                    chroot_run $MODULE_MERGED_DIR uncompress_files /etc/alternatives
                    chroot_run $MODULE_MERGED_DIR uncompress_files /usr/share/man
                    chroot_run $MODULE_MERGED_DIR remove_broken_links /etc/alternatives
                    chroot_run $MODULE_MERGED_DIR remove_broken_links /usr/share/man
                    set -e
                fi

                if [ -f $MODULE_UPPER_DIR/.package ] && [ $PACKAGE_VARIANT = "puzzle" ]; then
                    read_config $MODULE_UPPER_DIR/.package PACKAGE VERSION
                    MODULE_NUMBER=$(echo $MODULE | awk -F- '{ print $1 }')
                    MODULE_NAME="$MODULE_NUMBER-$PACKAGE-$VERSION"
                    rm $MODULE_UPPER_DIR/.package
                else
                    MODULE_NAME=$MODULE
                    if [ -f $MODULE_UPPER_DIR/.package ]; then
                        rm $MODULE_UPPER_DIR/.package
                    fi
                fi

                # run external actions
                if [ -f $SOURCE_MODULES_DIR/$MODULE/build ] && [ $SCRIPT_DIR != "/usr/bin" ]; then
                    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
                        if [ $KERNEL_BUILD_DKMS = "true" ]; then
                            cp $MODULE_UPPER_DIR/$MODULE.$BEXT $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT
                        else
                            cp $MODULE_UPPER_DIR/$MODULE.$BEXT $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT
                        fi
                    else
                        cp $MODULE_UPPER_DIR/$MODULE.$BEXT $WORK_DIR/image/$LIVEKITNAME/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT
                    fi
                elif [ -f $SOURCE_MODULES_DIR/$MODULE/build ] && [ $SCRIPT_DIR = "/usr/bin" ]; then
                    if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
                        if [ $KERNEL_BUILD_DKMS = "true" ]; then
                            cp $MODULE_UPPER_DIR/$MODULE.$BEXT $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT
                            chmod 666 $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT
                        else
                            cp $MODULE_UPPER_DIR/$MODULE.$BEXT $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT
                            chmod 666 $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT
                        fi
                    else
                        cp $MODULE_UPPER_DIR/$MODULE.$BEXT $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT
                        chmod 666 $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT
                    fi
                fi
                #fi

                module_chroot_finish_up

                module_chroot_umount_fs

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    module_build_cleanup
                fi

                module_chroot_cleanup

                module_remove_unofficial_repository

                mkmod_corefs $MODULE_UPPER_DIR

                if [ ! -f $SOURCE_MODULES_DIR/$MODULE/build ]; then
                    if [ $SCRIPT_DIR = "/usr/bin" ]; then
                        if [ "$(ls -A $MODULE_UPPER_DIR 2>/dev/null)" != "" ]; then
                            if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
                                if [ $KERNEL_BUILD_DKMS = "true" ]; then
                                    if [ $COMP_TYPE = "zstd" ]; then
                                        time mksquashfs $COREFS $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                    elif [ $COMP_TYPE = "xz" ]; then
                                        time mksquashfs $COREFS $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
                                    else
                                        time mksquashfs $COREFS $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                    fi
                                    chmod 666 $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT
                                else
                                    if [ $COMP_TYPE = "zstd" ]; then
                                        time mksquashfs $COREFS $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                    elif [ $COMP_TYPE = "xz" ]; then
                                        time mksquashfs $COREFS $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
                                    else
                                        time mksquashfs $COREFS $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                    fi
                                    chmod 666 $CURRENT_DIR/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT
                                fi
                            else
                                if [ $COMP_TYPE = "zstd" ]; then
                                    time mksquashfs $COREFS $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                elif [ $COMP_TYPE = "xz" ]; then
                                    time mksquashfs $COREFS $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
                                else
                                    time mksquashfs $COREFS $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                fi
                                chmod 666 $CURRENT_DIR/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT
                            fi
                        else
                            echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} ${RED}is empty${ENDCOLOR}. Nothing to do."
                        fi
                        module_chroot_umount_fs
                    else
                        if [ ! -f $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT ]; then
                            if [ "$(ls -A $MODULE_UPPER_DIR 2>/dev/null)" != "" ]; then
                                if [[ $MODULE == *"kernel"* ]] || [[ $MODULE == *"linux"* ]]; then
                                    if [ $KERNEL_BUILD_DKMS = "true" ]; then
                                        if [ $COMP_TYPE = "zstd" ]; then
                                            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                        elif [ $COMP_TYPE = "xz" ]; then
                                            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
                                        else
                                            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-ext-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                        fi
                                    else
                                        if [ $COMP_TYPE = "zstd" ]; then
                                            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                        elif [ $COMP_TYPE = "xz" ]; then
                                            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
                                        else
                                            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$KERNEL_SUFFIX-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                        fi
                                    fi
                                else
                                    if [ $COMP_TYPE = "zstd" ]; then
                                        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                                    elif [ $COMP_TYPE = "xz" ]; then
                                        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
                                    else
                                        time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE_NAME-$DISTRIBUTION_ARCH-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                                    fi
                                fi
                            else
                                echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} is empty. Nothing to do."
                            fi
                        else
                            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
                            echo -e "Please remove ${MAGENTA}$WORK_DIR/image/$LIVEKITNAME/$MODULE.$BEXT${ENDCOLOR} if you want to build ${MAGENTA}$MODULE${ENDCOLOR}."
                            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
                        fi
                    fi
                fi
            fi
            export_kernel
            export_locales
            PACKAGE=""
            VERSION=""
        done
    fi
}

# =================================================================
#
#
# =================================================================
function build_modules_live() {
    current_process
    if [ $CONTAINER_TYPE = "1" ]; then
        if [ ! -f /.minios-live ]; then
            setup_host
        fi
    fi

    MODULES_DIR=$WORK_DIR/modules

    cd $SOURCE_MODULES_DIR

    for MODULE in *; do
        if (ls $WORK_DIR/image/$LIVEKITNAME/*.$BEXT | grep -q $MODULE 2>/dev/null); then
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
            echo -e "Please remove ${MAGENTA}$WORK_DIR/image/$LIVEKITNAME/$MODULE.$BEXT${ENDCOLOR} if you want to build ${MAGENTA}$MODULE${ENDCOLOR}."
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
        else
            MODULE_UPPER_DIR="$MODULES_DIR/$MODULE-upper"
            MODULE_WORK_DIR="$MODULES_DIR/$MODULE-work"
            MODULE_MERGED_DIR="$MODULES_DIR/$MODULE-merged"
            mkmod_corefs $MODULE_UPPER_DIR
            if [ "$(ls -A $MODULE_UPPER_DIR 2>/dev/null)" != "" ]; then
                if [ $COMP_TYPE = "zstd" ]; then
                    time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
                elif [ $COMP_TYPE = "xz" ]; then
                    time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
                else
                    time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
                fi
            else
                echo -e "${MAGENTA}$MODULE_UPPER_DIR${ENDCOLOR} is empty. Nothing to do."
            fi
        fi
    done
}

function repack_module() {
    if [ $SCRIPT_DIR = "/usr/bin" ]; then
        cd $CURRENT_DIR
    fi
    OLD_MODULE=$MODULE
    MODULE=${MODULE%"-$OLD_COMP_TYPE.$BEXT"}
    if [ $COMP_TYPE = $OLD_COMP_TYPE ]; then
        echo "The module is already in the required compression format." && exit
    fi
    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        unsquashfs $OLD_MODULE
        mkmod_corefs $WORK_DIR/image/$LIVEKITNAME/squashfs-root
        if [ $COMP_TYPE = "zstd" ]; then
            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
        elif [ $COMP_TYPE = "xz" ]; then
            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
        else
            time mksquashfs $COREFS $WORK_DIR/image/$LIVEKITNAME/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
        fi

        rm -rf $WORK_DIR/image/$LIVEKITNAME/squashfs-root
        rm -f $WORK_DIR/image/$LIVEKITNAME/$OLD_MODULE
    else
        if (ls $CURRENT_DIR/*.$BEXT 2>/dev/null | grep -q $MODULE 2>/dev/null); then
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
            echo -e "Please remove $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT${ENDCOLOR} if you want to build ${MAGENTA}$MODULE${ENDCOLOR}."
            echo -e "${RED}!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!${ENDCOLOR}"
        else
            if [ $COMP_TYPE = "zstd" ]; then
                time mksquashfs $BUNDLES/$OLD_MODULE $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xcompression-level 19 -b 1024K -always-use-fragments -noappend || exit
            elif [ $COMP_TYPE = "xz" ]; then
                time mksquashfs $BUNDLES/$OLD_MODULE $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -Xbcj x86 -b 1024K -always-use-fragments -noappend || exit
            else
                time mksquashfs $BUNDLES/$OLD_MODULE $CURRENT_DIR/$MODULE-$COMP_TYPE.$BEXT -comp $COMP_TYPE -b 1024K -always-use-fragments -noappend || exit
            fi
        fi
    fi
}

function repack_modules() {
    current_process

    if [ $SCRIPT_DIR != "/usr/bin" ]; then
        cd $WORK_DIR/image/$LIVEKITNAME/
        for MODULE in *.$BEXT; do
            if [ -d $WORK_DIR/image/$LIVEKITNAME/squashfs-root ]; then
                rm -rf $WORK_DIR/image/$LIVEKITNAME/squashfs-root
            fi
            echo "Repacking module $MODULE"
            cd $WORK_DIR/image/$LIVEKITNAME
            OLD_COMP_TYPE=$(unsquashfs -s $MODULE | grep Compression | awk -F" " '{ print $2 }')
            repack_module
        done
    else
        cd $BUNDLES/
        for MODULE in *; do
            if (ls $BUNDLES/*-xz.$BEXT 2>/dev/null | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="xz"
                repack_module
            elif (ls $BUNDLES/*-lz4.$BEXT 2>/dev/null | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="lz4"
                repack_module
            elif (ls $BUNDLES/*-zstd.$BEXT 2>/dev/null | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="zstd"
                repack_module
            elif (ls $BUNDLES/*-lzo.$BEXT 2>/dev/null | grep -q $MODULE >>/dev/null 2>&1); then
                OLD_COMP_TYPE="lzo"
                repack_module
            fi
        done
    fi
}

function download_sources() {
    current_process

    if [ ! -d /opt/minios-live ]; then
        pkg update &&
            pkg install git
        mkdir -p /opt
        cd /opt
        git clone --depth=1 https://github.com/minios-linux/minios-live.git
        if [ -d /opt/minios-live/.git ]; then
            rm -rf /opt/minios-live/.git
        fi
        if [ -f /opt/minios-live/.gitignore ]; then
            rm -f /opt/minios-live/.gitignore
        fi
        # allow user to edit configs
        chmod 666 /opt/minios-live/linux-live/buildconfig
        chmod 666 /opt/minios-live/linux-live/config
        if id -nu 1000 >/dev/null && [ -d /home/$(id -nu 1000)/Desktop ]; then
            if [ ! -L /home/$(id -nu 1000)/Desktop/buildconfig ]; then
                ln -s /opt/minios-live/linux-live/buildconfig /home/$(id -nu 1000)/Desktop/buildconfig
            fi
            if [ ! -L /home/$(id -nu 1000)/Desktop/config ]; then
                ln -s /opt/minios-live/linux-live/config /home/$(id -nu 1000)/Desktop/config
            fi
        fi
        if [ $(stat -c %s /opt/minios-live/linux-live/minioslib) -ne $(stat -c %s /run/initramfs/lib/minioslib) ]; then
            cp /opt/minios-live/linux-live/minioslib /run/initramfs/lib/
        fi
        /opt/minios-live/install
    fi
}

# =================================================================
# =================================================================
# ==================== BATCH BUILD FUNCTIONS ======================
# =================================================================
# =================================================================

function generate_config_files() {
    cp -f "$SCRIPT_DIR/linux-live/buildconfig" "$SCRIPT_DIR/linux-live/container_buildconfig"
    cp -f "$SCRIPT_DIR/linux-live/config" "$SCRIPT_DIR/linux-live/container_config"

    VARS=("DISTRIBUTION_TYPE" "DISTRIBUTION" "DISTRIBUTION_ARCH" "DESKTOP_ENVIRONMENT" "PACKAGE_VARIANT" "INITRD_TYPE" "KERNEL_TYPE" "KERNEL_BPO" "KERNEL_AUFS" "COMP_TYPE" "LOCALE" "MULTILINGUAL")
    for VAR in "${VARS[@]}"; do
        sed -i -e "/$VAR=/s/=.*/=\"${!VAR}\"/" "$SCRIPT_DIR/linux-live/container_buildconfig"
    done
    sed -i -e "/TIMEZONE=/s/=.*/=\"${TIMEZONE//\//\\/}\"/" "$SCRIPT_DIR/linux-live/container_buildconfig"
}

function container_run() {
    if [ ! "$($container_engine ps -q -f name=mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$LANGUAGE_CODE$INITRD_TYPE$AUFS_SUFFIX$BPO_SUFFIX-$KERNEL_TYPE-$DISTRIBUTION_ARCH-$COMP_TYPE)" ]; then
        if [ "$($container_engine ps -aq -f status=exited -f name=mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$LANGUAGE_CODE$INITRD_TYPE$AUFS_SUFFIX$BPO_SUFFIX-$KERNEL_TYPE-$DISTRIBUTION_ARCH-$COMP_TYPE)" ]; then
            # cleanup
            $container_engine rm -f $CONTAINER_NAME
        fi
        generate_config_files
        # run your container
        $container_engine run -d --log-driver=journald --name $CONTAINER_NAME --privileged -v /dev:/dev --device-cgroup-rule 'b 7:* rmw' -v /build:/build \
            -e DISTRIBUTION_TYPE="$DISTRIBUTION_TYPE" \
            -e DISTRIBUTION="$DISTRIBUTION" \
            -e DESKTOP_ENVIRONMENT="$DESKTOP_ENVIRONMENT" \
            -e PACKAGE_VARIANT="$PACKAGE_VARIANT" \
            -e DISTRIBUTION_ARCH="$DISTRIBUTION_ARCH" \
            -e COMP_TYPE="$COMP_TYPE" \
            -e LOCALE="$LOCALE" \
            -e MULTILINGUAL="$MULTILINGUAL" \
            -e TIMEZONE="$TIMEZONE" \
            -e USER_NAME="live" \
            -e USER_PASSWORD="evil" \
            -e ROOT_PASSWORD="toor" \
            -e DEFAULT_TARGET="graphical" \
            -e ENABLE_SERVICES="" \
            -e DISABLE_SERVICES="" \
            -e AUTOLOGIN="true" \
            -e SSH_KEY="authorized_keys" \
            -e SCRIPTS="false" \
            -e CLOUD="false" \
            -e HIDE_CREDENTIALS="false" \
            -e SYSTEM_TYPE="puzzle" \
            -e DISTRIBUTION_VARIANT="minbase" \
            -e BATCH="true" \
            -e BUILD_TEST_ISO="false" \
            -e DEV_SYSTEM="false" \
            -e DEBIAN_FRONTEND_TYPE="noninteractive" \
            -e APT_CMD="apt-get" \
            -e BOOT_TYPE="hybrid" \
            -e UNION_BUILD_TYPE="overlayfs" \
            -e SYSTEMNAME="MiniOS" \
            -e USE_BOOTSTRAP="true" \
            -e USE_ROOTFS="true" \
            -e REMOVE_OLD_ISO="true" \
            -e REMOVE_SOURCES="true" \
            -e SKIP_SETUP_HOST="true" \
            -e DOWNLOAD_SOURCES="false" \
            -e REMOVE_DPKG_DB="false" \
            -e KERNEL_MODULES_ONLY="true" \
            -e REMOVE_LARGE_ICONS="true" \
            -e FILTER_MODULES="false" \
            -e FILTER_LEVEL="3" \
            -e INITRD_TYPE="$INITRD_TYPE" \
            -e KERNEL_TYPE="$KERNEL_TYPE" \
            -e KERNEL_BPO="$KERNEL_BPO" \
            -e KERNEL_AUFS="$KERNEL_AUFS" \
            -e KERNEL_BUILD_DKMS="$KERNEL_BUILD_DKMS" \
            -e NAMED_BOOT_FILES="false" \
            -e EXPORT_KERNEL="true" \
            -e MOVE_KERNEL="false" \
            -e EXPORT_LOGS="false" \
            -e USE_MX_REPO="false" \
            -e USE_ANTIX_REPO="false" \
            -e USE_UNOFFICIAL_REPOSITORY="false" \
            -e UNOFFICIAL_REPOSITORY_ADDRESS="http://10.3.0.3" \
            -e BUILD_FROM_SNAPSHOT="false" \
            -e SNAPSHOT_DATE="20220223T214737Z" \
            local/mlc /build/minios-live/install -
    fi
}

function live_run() {
    generate_config_files
    # run
    /usr/bin/env \
        DISTRIBUTION_TYPE="$DISTRIBUTION_TYPE" \
        DISTRIBUTION="$DISTRIBUTION" \
        DESKTOP_ENVIRONMENT="$DESKTOP_ENVIRONMENT" \
        PACKAGE_VARIANT="$PACKAGE_VARIANT" \
        DISTRIBUTION_ARCH="$DISTRIBUTION_ARCH" \
        COMP_TYPE="$COMP_TYPE" \
        LOCALE="$LOCALE" \
        MULTILINGUAL="$MULTILINGUAL" \
        TIMEZONE="$TIMEZONE" \
        USER_NAME="live" \
        USER_PASSWORD="evil" \
        ROOT_PASSWORD="toor" \
        DEFAULT_TARGET="graphical" \
        ENABLE_SERVICES="" \
        DISABLE_SERVICES="" \
        AUTOLOGIN="true" \
        SSH_KEY="authorized_keys" \
        SCRIPTS="false" \
        CLOUD="false" \
        HIDE_CREDENTIALS="false" \
        SYSTEM_TYPE="puzzle" \
        DISTRIBUTION_VARIANT="minbase" \
        LOGPATH="/var/log" \
        BATCH="true" \
        BUILD_TEST_ISO="false" \
        DEV_SYSTEM="false" \
        DEBIAN_FRONTEND_TYPE="noninteractive" \
        BOOT_TYPE="hybrid" \
        UNION_BUILD_TYPE="overlayfs" \
        SYSTEMNAME="MiniOS" \
        USE_BOOTSTRAP="true" \
        USE_ROOTFS="true" \
        REMOVE_OLD_ISO="true" \
        REMOVE_SOURCES="true" \
        SKIP_SETUP_HOST="true" \
        DOWNLOAD_SOURCES="false" \
        REMOVE_DPKG_DB="false" \
        KERNEL_MODULES_ONLY="true" \
        REMOVE_LARGE_ICONS="true" \
        FILTER_MODULES="false" \
        FILTER_LEVEL="3" \
        INITRD_TYPE="$INITRD_TYPE" \
        KERNEL_TYPE="$KERNEL_TYPE" \
        KERNEL_BPO="$KERNEL_BPO" \
        KERNEL_AUFS="$KERNEL_AUFS" \
        KERNEL_BUILD_DKMS="$KERNEL_BUILD_DKMS" \
        NAMED_BOOT_FILES="false" \
        EXPORT_KERNEL="true" \
        MOVE_KERNEL="false" \
        EXPORT_LOGS="false" \
        USE_MX_REPO="false" \
        USE_ANTIX_REPO="false" \
        USE_UNOFFICIAL_REPOSITORY="false" \
        UNOFFICIAL_REPOSITORY_ADDRESS="http://10.3.0.3" \
        BUILD_FROM_SNAPSHOT="false" \
        SNAPSHOT_DATE="20220223T214737Z" \
        /build/minios-live/install -
}

function container_status_check() {
    RUN=$($container_engine inspect $CONTAINER_NAME --format='{{.State.Status}}')
}

function container_build_finish() {
    if [ -f $SCRIPT_DIR/linux-live/container_buildconfig ]; then
        rm -f $SCRIPT_DIR/linux-live/container_buildconfig
    fi
    if [ -f $SCRIPT_DIR/linux-live/container_config ]; then
        rm -f $SCRIPT_DIR/linux-live/container_config
    fi
    if [ ! -d $SCRIPT_DIR/logs ]; then
        mkdir -p $SCRIPT_DIR/logs
    fi
    $container_engine logs $CONTAINER_NAME >&$SCRIPT_DIR/logs/$CONTAINER_NAME.log
    START=$(docker inspect --format='{{.State.StartedAt}}' $CONTAINER_NAME)
    STOP=$(docker inspect --format='{{.State.FinishedAt}}' $CONTAINER_NAME)
    START_TIMESTAMP=$(date --date=$START +%s)
    STOP_TIMESTAMP=$(date --date=$STOP +%s)
    echo "Container runtime count: $CONTAINER_NAME $(($STOP_TIMESTAMP - $START_TIMESTAMP)) seconds"
    echo "Container runtime count: $CONTAINER_NAME $(($STOP_TIMESTAMP - $START_TIMESTAMP)) seconds" >>$SCRIPT_DIR/logs/$CONTAINER_NAME.log
    if [ "$($container_engine ps -aq -f status=exited -f name=$CONTAINER_NAME)" ]; then
        # cleanup
        $container_engine rm -f $CONTAINER_NAME && rm -rf "/build/minios-live/build/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH"
    fi
    if [ -d /build/minios-live/build/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH ]; then
        echo "/build/minios-live/build/$DISTRIBUTION-$PACKAGE_VARIANT-$DISTRIBUTION_ARCH exists"
    fi
}

function container_build_run() {
    local AUFS_SUFFIX BPO_SUFFIX
    DISTRIBUTION_TYPE="debian"
    DISTRIBUTION="$1"
    DESKTOP_ENVIRONMENT="$2"
    PACKAGE_VARIANT="$3"
    DISTRIBUTION_ARCH="$4"
    INITRD_TYPE="$5"
    KERNEL_TYPE="$6"
    KERNEL_BPO="$7"
    KERNEL_AUFS="$8"
    KERNEL_BUILD_DKMS="$9"
    COMP_TYPE="${10}"
    LOCALE="${11}"
    MULTILINGUAL="false"
    TIMEZONE="${12}"

    if [ $MULTILINGUAL = "true" ]; then
        LANGUAGE_CODE=""
    else
        LANGUAGE_CODE="$(echo $LOCALE | cut -d_ -f1)-"
    fi

    case $1 in
    trusty | xenial | bionic | focal | groovy | hirsute | impish | jammy | kinetic | lunar | mantic)
        DISTRIBUTION_TYPE="ubuntu"
        ;;
    esac

    if [ $KERNEL_BPO = "true" ]; then
        BPO_SUFFIX="-bpo"
    fi
    if [ $KERNEL_AUFS = "true" ]; then
        AUFS_SUFFIX="-aufs"
    fi
    CONTAINER_NAME="mlc-$DISTRIBUTION-$DESKTOP_ENVIRONMENT-$PACKAGE_VARIANT-$LANGUAGE_CODE$INITRD_TYPE$AUFS_SUFFIX$BPO_SUFFIX-$KERNEL_TYPE-$DISTRIBUTION_ARCH-$COMP_TYPE"

    if [ ! "$($container_engine ps -q -f name=$CONTAINER_NAME)" ]; then
        if [ "$($container_engine ps -aq -f status=exited -f name=$CONTAINER_NAME)" ]; then
            # cleanup
            $container_engine rm -f $CONTAINER_NAME
        fi
        # run your container
        container_run
    fi

    container_status_check
    if [ "$RUN" = "running" ]; then
        echo "Container $CONTAINER_NAME has been started."
    fi

    while container_status_check; do
        if [ "$RUN" = "running" ]; then
            printf "."
            sleep 5
        else
            if [ "$($container_engine inspect $CONTAINER_NAME --format='{{.State.ExitCode}}')" != "0" ] 2>/dev/null; then
                printf "\nERROR: Container $CONTAINER_NAME stopped with error. Exit code $($container_engine inspect $CONTAINER_NAME --format='{{.State.ExitCode}}')\n"
                container_build_finish
            else
                printf "\nContainer $CONTAINER_NAME stopped, proceeding...\n"
                container_build_finish
            fi
            break
        fi
    done
}

function live_build_run() {
    DISTRIBUTION_TYPE="debian"
    DISTRIBUTION="$1"
    DESKTOP_ENVIRONMENT="$2"
    PACKAGE_VARIANT="$3"
    DISTRIBUTION_ARCH="$4"
    INITRD_TYPE="$5"
    KERNEL_TYPE="$6"
    KERNEL_BPO="$7"
    KERNEL_AUFS="$8"
    KERNEL_BUILD_DKMS="$9"
    COMP_TYPE="${10}"
    LOCALE="${11}"
    MULTILINGUAL="${12}"
    TIMEZONE="${13}"
    case $1 in
    trusty | xenial | bionic | focal | groovy | hirsute | impish | jammy | kinetic | lunar | mantic)
        DISTRIBUTION_TYPE="ubuntu"
        ;;
    esac

    live_run
}
